#pragma once

#include "Common.h"

namespace nsSorting
{
	// Методы сортировки специального назначения
	namespace nsSpecialPurposeSortingMethods
	{
		void main();

		// Программа 11.1 Идеальное тасование и обратное идеальное тасование
		template <class Item>
		void shuffle(Item a[], int l, int r)
		{
			int i, j, m = (l + r) / 2;
			const int maxN = 100;
			static Item aux[maxN];
			for (i = l, j = 0; i <= r; i += 2, j++)
			{
				aux[i] = a[l + j];
				aux[i + 1] = a[m + 1 + j];
			}
			for (i = l; i <= r; i++)
				a[i] = aux[i];
		}

		template <class Item>
		void unshuffle(Item a[], int l, int r)
		{
			int i, j, m = (l + r) / 2;
			const int maxN = 100;
			static Item aux[maxN];
			for (i = l, j = 0; i <= r; i += 2, j++)
			{
				aux[l + j] = a[i];
				aux[m + 1 + j] = a[i + 1];
			}
			for (i = l; i <= r; i++)
				a[i] = aux[i];
		}

		// Программа 11.2.Нечетно-четное слияние Бэтчера (рекурсивная версия)
		template <class Item>
		void merge(Item a[], int l, int m, int r)
		{
			if (r == l + 1)
				nsCommon::compexch(a[l], a[r]);
			if (r < l + 2)
				return;
			unshuffle(a, l, r);
			merge(a, l, (l + m)/2, m);
			merge(a, m + 1, (m + 1 + r)/2, r);
			shuffle(a, l, r);
			for (int i = l + 1; i < r; i += 2)
				nsCommon::compexch(a[i], a[i + 1]);
		}

		// Программа 11.3.Нечетно-четное слияние Бэтчера(нерекурсивная версия)
		template <class Item>
		void merge1(Item a[], int l, int m, int r)
		{
			int N = r - l + 1; // предполагается, что N/2 это m-l+1 
			for (int k = N / 2; k > 0; k /= 2)
				for (int j = k % (N / 2); j + k < N; j += k + k)
					for (int i = 0; i < k; i++)
						nsCommon::compexch(a[l + j + i], a[l + j + i + k]);
		}

		// Программа 11.4.Нечетно-четная сортировка Бэтчера(нерекурсивная версия)
		template <class Item>
		void batchersort(Item a[], int l, int r)
		{
			int N = r - l + 1;
			for (int p = 1; p < N; p += p)
				for (int k = p; k > 0; k /= 2)
					for (int j = k % p; j + k < N; j += (k + k))
						for (int i = 0; i < N - j - k; i++)
							if ((j + i) / (p + p) == (j + i + k) / (p + p))
								nsCommon::compexch(a[l + j + i], a[l + i + j + k]);
		}


		// В данной главе мы исследуем примеры методов сортировки, которые разрабатываются для эффективного применения на конкретных типах машин.
		// В первую очередь мы рассмотрим версию сортировки слиянием, известную как нечетно-четная сортировка слиянием Бэтчера(Batcher's odd-even mergesort).
		// В ее основу положен алгоритм слияния, функционирующий по принципу разделяй и властвуй, который использует только операции сравнения - обмена, при этом для перемещения данных употребляются операции идеального тасования(perfect-shuffle) и операция идеального обратного тасования(perfect unshuffle).
		// Сеть сортировки (sorting network) представляет собой простую абстракцию для аппаратных средств сортировки.
		// Такая сеть состоит из соединенных друг с другом посредством межкомпонентных связей компараторов(comparators), представляющих собой модули, способные выполнять операции сравнения-обмена.
		// Другой важной проблемой абстрактной сортировки является проблема внешней сортировки(external sorting); в этом случае сортируемый файл обладает такими огромными размерами, что не помещается в оперативной памяти.
		// В заключение мы рассмотрим параллельную сортировку (parallel sorting) на тот случай, когда сортируемый файл распределяется между независимыми параллельными процессорами.
		// Аппаратные средства сортировки низкого уровня должны состоять из простых компонентов; внешняя сортировка в общем случае требует поблочного доступа к особо крупным файлам данных, а параллельная сортировка накладывает определенные ограничения на связи с процессорами.
		
		// 11.1 Четно-нечетная сортировка слиянием Бэтчера
		// Для начала мы рассмотрим метод сортировки, в основе которых лежат две следующих абстрактных операции:
		// операция сравнения обмена(compare-exchange) и операция идеального тасования(perfect shuffle) (вместе с ее антиподом, операцией идеального обратного тасования(perfect unshuffle)).
		// Алгоритм известен как нечетно-четная сортировка слиянием Бэтчера(Batcher's odd-even mergesort).
		// В настоящий момент нас интересуют методы, в условиях которых данные проверяются исключительно через операций сравнения-обмена.
		// Стандартные операции сравнения исключаются: операции сравнения-обмена не возвращают результат, следовательно, у программы нет возможности выполнять те или иные действия в зависимости от конкретных значений данных.
		// Определение 11.1 Неадаптивный алгоритм сортировки - это алгоритм, в котором последовательность выполняемых операций зависит только от числа входных данных, а не от значений ключей.
		// Неадаптивные методы эквивалентны неветвящимся программам сортировки: они могут быть записаны в виде простого перечня операций сравнения-обмена.
		// Основная цель при разработке алгоритма состоит в том, чтобы определить для каждого N фиксированную последовательность операций compexch, которые способны выполнить сортировку любого набора из N ключей.
		// Программа 11.1 представляет собой реализацию других абстрактных операций, которыми мы будем пользоваться в дальнейшем - операции идеального тасования и операции обратного идеального тасования.
		// Идеальное тасование переупорядочивает массив так, как может перетасовать колоду карт только большой специалист этого дела:
		// колода делится точно наполовину, затем карты по одной берутся из каждой половины колоды.
		// Обратное идеальное тасование выполняет обратную процедуру: мы попеременно откладываем карты в верхнюю и нижнюю половину колоды.
		// Сортировка Бэтчера представляет собой в точности нисходящую сортировку слиянием, описанную в разделе 8.3;
		// различие состоит лишь в том, что вместо одной из адаптивных реализаций слияний из главы 8 она использует нечетно-четное слияние Бэтчера, представляющее собой неадаптивное нисходящее рекурсивное слияние.
		// На протяжении этого раздела и раздела 11.2 мы неявно предполагаем, что число сортируемых элементов является степенью 2.
		// Слияние Бэтчера само по себе является рекурсивным методом "разделяй и властвуй".
		// Лемма 11.1. (Принцип нулей и единиц) Если неадаптивная программа выдает отсортированный выход в случае, когда входы состоят только из 0 и 1, то она делает то же, когда входами являются произвольные ключи.
		// Лемма 11.2. Нечетно-четное слияние Бэтчера (программа 11.2) это правильный метод слияния.

		// 11.2.Сети сортировки
		// Простейшей моделью для изучения неадаптивных алгоритмов сортировки является абстрактная машина, которая способна осуществлять доступ к данным только с помощью операций сравнения-обмена.
		// Такая машина называется сетью сортировки (sorting network).
		// Сеть сортировки построена из атомарных модулей сравнения-обмена (compare-exchange modules) или компараторов(comparators), которые соединены между собой линиями связи таким образом, что становится возможным выполнение полной сортировки общего вида.
		// Еще одним важным применением сетей сортировки является модель параллельных вычислений.
		// Если два компаратора не используют одних и тех же линий для ввода данных, то мы полагаем, что они могут работать одновременно.
		// Для любой заданной сети нетрудно сгруппировать компараторы в последовательность параллельных каскадов(parallel stage), каждый из которых состоит из компараторов, которые могут работать одновременно.
		// Чтобы параллельные вычисления были эффективными, нашей задачей становится разработка сетей с минимально возможным числом параллельных каскадов.
		// Программа 11.3. является восходящей реализацией слияния Бэтчера без операции тасования.

		// Лемма 11.3.Сети нечетно-четной сортировки Бэтчера используют приблизительно N*((lg(N))^2)/4 компараторов и могут быть выполнены за(lg(N)^2)/2 параллельных шагов.
		// Эту схему межкомпонентных соединений иногда называют сачком для ловли бабочек (butterfly network).
		// В число более важных примеров входят быстрые преобразования Фурье и полиномиальное приближение.

		// 11.3. Внешняя сортировка
		// Мы переходим к рассмотрению другого аспекта задачи абстрактной сортировки, которая возникает, когда сортируемый файл настолько велик, что не помещается целиком в оперативной памяти компьютера.
		// Для описания такого рода ситуаций мы используем термин внешняя сортировка(external sorting).
		// Кроме того, будет полезно изучить методы сортировки, использующие две простейшие базовые операции:
		// - операция считывания(read) данных из внешнего запоминающего устройства в оперативную память и
		// - операция записи(write) данных из оперативной памяти на внешнее запоминающее устройство
		// Абстрактная модель сортировки, которой мы в дальнейшем будем  пользоваться, построена на предположении, что сортируемый файл слишком велик, чтобы полностью поместиться в оперативную память, и что он определяет значения двух других параметров : времени выполнения сортировки(число проходов по данным) и количество используемых внешних устройств.
		// Мы полагаем, что в нашем распоряжении имеются
		// - N записей на внешнем устройстве, сортировку которых мы должны выполнить
		// - пространство оперативной памяти, достаточное для размещения М записей
		// - 2Р внешних устройств, которыми мы можем пользоваться во время сортировки.
		// Большая часть методов внешней сортировки соблюдает следующие принципы общего характера.
		// Выполняется первый проход по сортируемому файлу, в процессе которого производится его разбиение на блоки, размер которых примерно соответствует пространству оперативной памяти, после чего выполняется сортировка этих блоков.
		// Затем осуществляется слияние отсортированных блоков, при необходимости с этой целью выполняются несколько проходов файла, при этом с каждым проходом степень упорядоченности возрастает, пока весь файл не окажется отсортированным.
		// Такой подход называется сортировкой-слиянием(sort - merge), он с успехом применяется на практике с тех пор, когда компьютеры получили широкое распространение в коммерческих приложениях в пятидесятых годах прошлого столетия.
		// Простейшая стратегия сортировки-слияния, получившая название сбалансированного многопутевого слияния(balanced multiway merging).
		// метод состоит из прохода, осуществляющего начальное распределение(initial distribution), за которым следуют несколько проходов многопутевого слияния(multiway merging passes).
		// Лемма 11.4. При наличии 2Р внешних устройств и оперативной памяти, достаточной для размещения М записей, сортировка-слияние, в основу которой положено Р-путевое сбалансированное слияние, требует выполнения 1 + /log_P(N/M)\ проходов.
		
		// 11.4. Различные реализации сортировки-слияния
		// Мы рассмотрим два усовершенствования сортировки-слияния, позволяющих снизить объем затрат.
		// - Первое из них, метод выбора с замещением(replacement selection), оказывает на время выполнения тот же эффект, что и объем пространства используемой оперативной памяти;
		// - следующий метод, многофазное слияние(polyphase merging), обеспечивает тот же эффект, что и увеличение числа используемых нами устройств.
		// Лемма 11.5. В случае произвольных ключей размеры блоков данных, полученных посредством выборки с замещением, в два раза превосходят размер сортирующего дерева.
		// Если ни одному из ключей не предшествуют в файле более М ключей, превосходящих его по значению, то этот файл может быть полностью отсортирован за один проход выборки с замещением, и при этом никакое слияние не понадобится!
		// Эта возможность служит наиболее веским аргументом в пользу практического применения выборки с замещением.
		// Разработаны несколько хитроумных алгоритмов, которые обеспечивают занятость всех внешних устройств за счет замены устройства, на котором производится слияние отсортированных блоков данных небольших размеров.
		// Простейший из этих методов получил название многофазное слияние(polyphase merging).
		// Основополагающая идея многофазного слияния заключается в том, чтобы распределять отсортированные блоки, полученные в результате выполнения выборки с замещением на доступные лентопротяжные устройства с определенной степенью неравномерности(оставляя одно устройство пустым) с последующим применением стратегии "сливать до опустошения" (merge - until - empty):
		// поскольку сливаемые ленты неодинаковы по длине, одна из них будет исчерпана раньше остальных, после чего она может быть использована как выходная.
		// Лемма 11.6. При наличии трех внешних устройств и пространства оперативной памяти, достаточного для размещения М записей, сортировка-слияние, в основу которой положена операция выборки с замещением с последующим двухпутевым многофазным слиянием, выполняет в среднем 1 + /log_f{N/M)\ / f эффективных проходов.
		// В виртуальной памяти мы получаем возможность обращаться к крупным блокам данных, содержащим большое количество записей, полагаясь на систему в вопросе гарантированной доставки адресуемых данных с внешних запоминающих устройств в оперативную память, когда нам это нужно; при этом возникает впечатление, что доступ к данным в смысле удобства ничем не отличается от прямого доступа к данным, находящимся в оперативной памяти.
		// Но если данные, к которым производится доступ, разбросаны в разных местах крупного файла, то система виртуальной памяти начнет испытывать перегруз(thrash), затрачивая все свое время на доступ к данным во внешней памяти, результаты которого будут катастрофическими.

		// 11.5. Параллельная процедура сортировки-слияния
		// Абстрактная модель, которую мы используем для представления параллельной обработки данных, базируется на предположении, что сортируемые файлы распределяются между независимыми процессорами.Мы полагаем, что имеются
		// - N записей, подлежащих сортировке
		// - Р процессоров, способных принять (N/P) записей.
		// рассматриваемая модель не учитывает одну из наиболее важных проблем, которая весьма актуальна для параллельной обработки данных:
		// ограничения, которые накладываются на обмен данными между процессорами.
		// Определение 11.2. Компаратор слияния принимает на входе два отсортированных файла размером М и выдает на выход два отсортированных файла:
		// один из них содержит М-й наименьший из 2M входных элементов, а другой содержит М-й наибольший из 2M входных элементов.
		// Лемма 11.7. Мы можем выполнить сортировку файла размером N, поделив его на M/N блоков размером М с последующей сортировкой каждого файла, после чего используем сеть сортировки со встроенными в нее компараторами.
		// Будем называть метод, описываемый леммой 11.7, поблочной сортировкой (block sorting).
		// Лемма 11.8. Поблочная сортировка на Р процессорах с использованием сортировки Бэтчера с компараторами слияния может выполнить сортировку N записей примерно за ((lgP)^2)/2 параллельных шагов.
	}
}

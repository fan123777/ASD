#pragma once

// Анализ
namespace nsAnalysis
{
	void main();

	// алгоритм быстрого поиска(quick-find)
	void program1(int N, int a[][2]);
	// алгоритм быстрого объединения(quick-union)
	void program2(int N, int a[][2]);
	// алгоритм взвешенного быстрого объединения(weighted quick-union) 
	void program3(int N, int a[][2]);
	// алгоритм сжатия пути делением пополам(weighted quick-union with path compression by halving)
	void program4(int N, int a[][2]);

	// 1.1 Алгоритмы
	
	// 1.2 Пример задачи : связность
	// Предположим, что имеется последовательность пар целых чисел, в которой каждое целое число представляет объект некоторого типа, а пара p - q интерпретируется в значении "р связано с q".
	// Задача состоит в написании программы для исключения лишних пар из набора : когда программа вводит пару р - q, она должна выводить эту пару только в том случае, если просмотренные до данного момента пары не предполагают, что р связано с q.
	// в этой главе без ущерба для общности можно предположить, что имеется N объектов с целочисленными именами от 0 до N - 1.
	// Входной набор пар называется графом(Graph), а выходной набор пар — остовным деревом (spanning tree) этого графа, которое связывает все объекты.
	// разработаем алгоритмы и структуры данных, которые могут:
	// - находить набор, содержащий данный элемент
	// - замещать наборы, содержащие два данных элемента, их объединением
	// Задача связности легко решается посредством абстрактных операций find (поиск) и union (объединение).
	// После считывания новой пары p-q из ввода мы выполняем операцию find для каждого члена пары.Если члены пары находятся в одном наборе, мы переходим к следующей паре; если нет, то выполняем операцию union и записываем пару.
	// Наборы представляют связанные компоненты: поднаборы объектов, характеризующиеся тем, что любые два объекта в данном компоненте связаны. Этот подход сводит разработку алгоритмического решения задачи связности к задачам определения структуры данных, которая представляет наборы, и разработке алгоритмов union и find, которые эффективно используют эту структуру данных.
	
	// 1.3 Алгоритмы объединение-поиск
	// Программа 1.1 — реализация простого алгоритма, называемого алгоритмом быстрого поиска, решающего задачу связности.
	// что р и q связаны тогда и только тогда, когда p - ая и q - ая записи массива равны.
	// Лемма 1.1 Алгоритм быстрого поиска выполняет не менее М N инструкций для решения задачи связности при наличии N объектов, для которых требуется выполнение М операций объединения.
	// связи между обьектами в этом представлении не обязательно соответствует связям во вводимых парах — они представляют собой информацию, запоминаемую алгоритмом, чтобы иметь возможность определить, соединены ли пары, которые будут вводиться в будущем.
	// Лемма 1.2 При наличии М пар N объектов, когда М > N, для решения задачи связности алгоритму быстрого объединения может потребоваться выполнение более чем МN/2 инструкций.
	// Вместо того чтобы произвольным образом соединять второе дерево с первым для выполнения операции union, можно отслеживать количество узлов в каждом дереве и всегда соединять меньшее дерево с большим.
	// Лемма 1.3 Для определения того, связаны ли два из N объектов, алгоритму взвешенного быстрого объединения требуется отследить максимум lg(N) указателей.
	// не превышает Мlg(N)
	// В идеале было бы желательно, чтобы каждый узел указывал непосредственно на корень своего дерева.
	// Мы называем этот вариант взвешенным быстрым объединением посредством сжатия пути делением пополам
	
	// 1.4 Перспектива 
	// - Принятие формулировки полной и частной задачи, включая определение основных абстрактных операций, присущих задаче
	// - Тщательная разработка краткой реализации для простого алгоритма. 
	// - Разработка усовершенствованных реализаций путем пошагового улучшения, проверки эффективности идей усовершенствований посредством эмпирического или математического анализа либо их обоих.
	// - Определение высокоуровневых абстрактных представлений структур данных или алгоритмов посредством операций, которые позволяют эффективно разрабатывать усовершенствованные версии на высоком уровне.
	// - Стремление к получению гарантированной производительности в худшем случае, когда это возможно, но принятие хорошей производительности при работе с реальными данными, когда это доступно.

	// 1.5 Обзор тем 
}

// Принципы анализа алгоритмов
namespace nsAnalysisPrinciples
{
	void main();
}
#pragma once

#include "Common.h"

namespace nsSorting
{
	// Слияние и сортировкаслиянием
	namespace nsMergeAndMergeSort
	{
		void main();

		// Программа 8.1.Слияние
		template <class Item>
		void mergeAB(Item c[], Item a[], int N, Item b[], int M)
		{
			for (int i = 0, j = 0, k = 0; k < N + M; k++)
			{
				if (i == N)
				{
					c[k] = b[j++];
					continue;
				}
				if (j == M)
				{
					c[k] = a[i++];
					continue;
				}
				c[k] = (a[i] < b[j]) ? a[i++] : b[j++];
			}
		}

		// Программа 8.2.Абстрактное обменное слияние
		template <class Item>
		void merge(Item a[], int l, int m, int r)
		{
			int i, j;
			const int maxN = 100;
			static Item aux[maxN];
			for (i = m + 1; i > l; i--)
				aux[i - 1] = a[i - 1];
			for (j = m; j < r; j++)
				aux[r + m - j] = a[j + 1];
			for (int k = l; k <= г; k++)
			if (aux[j] < aux[i])
				a[k] = aux[j--];
			else
				a[k] = aux[i++];
		}

		// Программа 8.3.Нисходящая сортировка слиянием
		template <class Item>
		void mergesort(Item a[], int l, int r)
		{
			if (r <= l)
				return;
			int m = (r + l) / 2;
			mergesort(a, l, m);
			mergesort(a, m + 1, r);
			merge(a, l, m, r);
		}

		// Программа 8.4.Сортировка слиянием без копирования
		template <class Item>
		void mergesortABr(Item a[], Item b[], int l, int r)
		{
			if (r - l <= 10)
			{
				nsCommon::insertion(a, l, r);
				return;
			}

			int m = (l + r) / 2;
			mergesortABr(b, a, l, m);
			mergesortABr(b, a, m + 1, r);
			mergeAB(a + l, b + l, m - l + 1, b + m + 1, r - m);
		}

		template <class Item>
		void mergesortAB(Item a[], int l, int r)
		{
			const int maxN = 100;
			static Item aux[maxN];
			for (int i = l; i <= r; i++)
				aux[i] = a[i];
			mergesortABr(a, aux, l, r);
		}

		// Программа 8.5.Восходящая сортировка слиянием
		inline int min(int A, int В)
		{
			return (A < В) ? A : В;
		}

		template <class Item>
		void mergesortBU(Item a[], int l, int r)
		{
			for (int m - 1; m <= r - l; m = m + m)
			for (int i = l; i <= r - m; i += m + m)
				merge(a, i, i + m - 1, min(i + m + m - 1, r));
		}

		// Программа 8.6.Слияние связных списков
		template<typename Item>
		nsCommon::link<Item> merge(nsCommon::link<Item> a, nsCommon::link<Item> b)
		{
			using namespace nsCommon;
			node<Item> dummy(0); link<Item> head = &dummy, с = head;
			while ((a != 0) && (b != 0))
			if (a->item < b->item)
			{
				c->next = a;
				с = a;
				a = a->next;
			}
			else
			{
				c->next = b; с = b; b = b->next;
			}
			c->next = (a == 0) ? b : a;
			return head->next;
		}

		// Программа 8.7.Сортировка связных списков слиянием сверху вниз
		template<typename Item>
		nsCommon::link<Item> mergesort(nsCommon::link<Item> c)
		{
			using namespace nsCommon;
			if (c == 0 || c->next = 0)
				return c;
			link<Item> a = c, b = c->next;
			while ((b != 0) && (b->next != 0))
			{
				с = c->next; b = b->next->next;
			}
			b = c->next;
			c->next = 0;
			return merge(mergesort(a), mergesort(b));
		}

		// Программа 8.8.Восходящая сортировка связных списков слиянием
		template<typename Item>
		nsCommon::link<Item> mergesort1(nsCommon::link<Item> t)
		{
			using namespace nsCommon;
			Queue<link<Item>> Q;
			if (t == 0 || t->next == 0)
				return t;
			for (link<Item> u = 0; t != 0; t = u)
			{
				u = t->next; t->next = 0; Q.put(t);
			}
			t = Q.get();
			while (!Q.empty())
			{
				Q.put(t); t = merge(Q.get(), Q.get());
			}
			return t;
		}


		// Слияние является основой для простого алгоритма сортировки типа "разделяй и властвуй" а также для его двойника - алгоритма восходящей(снизу - вверх) сортировки слиянием, при этом оба из них достаточно просто реализуются.
		// В этой главе рассматривается сортировка слиянием (mergesort), которая является дополнением быстрой сортировки в том, что она состоит из двух рекурсивных вызовов с последующей процедурой слияния.
		// Одним из наиболее привлекательных свойств сортировки слиянием является тот факт, что она сортирует файл, состоящий из N элементов, за время, пропорциональное NlogN, независимо от характера входных данных.
		// Основной недостаток сортировки слиянием заключается в том, что прямолинейные реализации этого алгоритма требуют дополнительного пространства памяти, пропорционального N.
		// Cортировка методом слияния достойна того, чтобы к ней проявить внимание в случае, когда на первый план выходят такие показатели как быстродействие, необходимость избегать наихудших случаев, возможность использования дополнительного пространства памяти.
		// Сортировка слиянием - это устойчивая сортировка, и данное обстоятельство склоняет чашу весов в ее пользу в тех приложениях, в которых устойчивость имеет важное значение.
		// Другое свойство сортировки слиянием, которое приобретает важное значение в некоторых ситуациях, является тот факт, что сортировка слиянием обычно реализуется таким образом, что она осуществляет, в основном, последовательный доступ к данным(один элемент за другим).
		// Например, сортировка слиянием — именно тот метод, который можно применить к связным спискам, для которых из всех методов доступа применим только метод последовательного доступа.
		// Слияние часто используется в качестве основы для сортировки на специализированных и высокопроизводительных машинах, поскольку именно последовательный доступ к данным в подобного рода системах обработки данных является самым быстрым.
		
		// 8.1. Двухпутевое слияние
		// Более эффективная стратегия предусматривает сортировку пакета(небольших размеров) новых элементов, с последующим слиянием полученного файла небольших размеров с большим главным файлом.
		
		// 8.2. Абстрактное обменное слияние 
		// При условии, что мы отказались копировать массивы, чтобы реализовать обменную абстракцию, мы просто представляем второй файл во время его копирования в обратном порядке(без дополнительных затрат), так что связанный с ним указатель перемещается справа налево.
		// Эта операция приводит к тому, что наибольший элемент, в каком бы он файле не находился, служит служебной меткой для другого массива.
		// Последовательность ключей, которая сначала увеличивается, а затем уменьшается(или сначала уменьшается, а затем увеличивается), называется битонной(bitonic) последовательностью.
		
		// 8.3. Нисходящая сортировка слиянием 
		// Чтобы отсортировать заданный файл, мы делим его на две части, выполняем рекурсивную сортировку обеих частей, после чего производим их слияние.
		// алгоритм является одним из широко известных примеров использования принципа "разделяй и властвуй"
		// время ее выполнения пропорционально N*log(N)
		// Для любого заданного N мы строим дерево, получившее название "дерево разделяй и властвуй", которое описывает размер подфайлов, подвергаемых обработке в процессе выполнения программы.
		// если N есть 1, то в таком дереве имеется всего лишь один узел с меткой 1; в противном случае дерево состоит из узла, содержащего файл размером N, представляющего корень, поддерева, представляющего левый подфайл размера |_N/2_| и поддерева, представляющего правый подфайл размера /N/2\.
		// Например, общее количество операций сравнения, выполняемых алгоритмом, в точности равно сумме всех меток узлов.
		// Лемма 8.1. Сортировка слиянием требует выполнения примерно N*lg(N) операций сравнения для сортировки любого файла из N элементов.
		// Лемма 8.2. Сортировка слиянием использует дополнительное пространство, пропорциональное N.
		// Сортировка слиянием также эффективна, если сортируемый файл организован как связный список.
		// Лемма 8.3. Сортировка слиянием устойчива, если устойчив используемый при этом метод слияния.
		// Лемма 8.4. Потребность ресурсов со стороны сортировки слиянием не чувствительна по отношению к исходному порядку входного файла.
		
		// 8.4. Усовершенствования базового алгоритма 
		// более совершенная обработка файлов небольших размеров приводит к тому, что улучшается и весь алгоритм.
		// переключение на сортировку вставками подфайлов небольших размеров приводит к уменьшению времени выполнения типовой реализации операции сортировки слиянием от 10 до 15 процентов.
		// сочетание всех предложенных выше усовершенствований ускоряют сортировку слиянием примерно на 40 процентов, однако сортировка слиянием все еще выполняется примерно на 25 процентов медленнее, чем быстрая сортировка.

		// 8.5.Восходящая сортировка слиянием
		// Лемма 8.5. Все слияния на каждом проходе восходящей сортировки слиянием манипулируют файлами, размер которых выражен степенью 2, за исключением разве что размера последнего файла.
		// Лемма 8.6. Количество проходов при восходящей сортировке слиянием по файлу из N элементов в точности равно числу бит в двоичном представлении N(при этом ведущие нули игнорируются).

		// 8.6.Производительность сортировки слиянием
		
		// 8.7. Реализация сортировки слиянием, ориентированной на связные списки
		// Для нахождения середины списка программа 8.7 использует следующий прием:
		// разные реализации могут делать это либо передавая длину списка как параметр в рекурсивную программу, либо сохраняя длину в самом списке.
		// Такая программа в рекурсивной формулировке проста для понимания, даже если реализует достаточно сложный алгоритм.
		// Одна из забавных версий восходящей сортировки связных списков слиянием, которую нетрудно сформулировать, напрашивается сама собой:
		// поместить элементы списка в циклический список, после чего перемещаться по списку, сливая пары упорядоченных подфайлов до тех пор, пока дело не будет сделано.

		// 8.8.Возврат к рекурсии
		// быстрая сортировка соответствует тому, что каждый руководящий работник затрачивает свои усилия на то, чтобы правильно разбить задачу на подзадачи, так что работа будет успешно выполнена, если успешно выполнены все подзадачи, в то время как сортировка слиянием соответствует тому, что каждый руководящий работник выполняет быструю произвольную разбивку задачу напополам, а затем затрачивает все свои усилия на то, чтобы преодолеть последствия подобных действий после того, как соответствующие подзадачи будут решены.
	}
}

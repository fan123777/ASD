#pragma once

namespace nsSearch
{
	// Сбалансированные деревья
	namespace nsBalancedTrees
	{
		void main();

		// Описанные в предыдущей главе алгоритмы, использующие деревья бинарного поиска(BST-деревья) успешно работают для широкого множества приложений, однако их производительность существенно снижается в худших случаях.
		// Уже упорядоченные файлы, файлы с большим количеством дублированных ключей, упорядоченные в обратном порядке файлы или файлы с любым большим сегментом, имеющим простую структуру, могут приводить к тому, что время построения BST-дерева определяется квадратичной, а время поиска — линейной зависимостью.
		// Один из подходов к повышению степени сбалансированности в BST-деревьях связан с периодическим явным выполнением их повторной балансировки.
		// Будут показаны решения этой задачи, являющиеся типичными примерами трех базовых подходов к обеспечению гарантированной производительности при разработке алгоритмов:
		// рандомизации, амортизации и оптимизации.
		// При использовании рандомизованного алгоритма принятие случайного решения встроено в сам алгоритм, что радикально уменьшает вероятность возникновения худшего случая сценария(независимо от входного массива данных).
		// Амортизационный подход заключается в однократном выполнении дополнительных действий во избежание выполнения большего объема работы впоследствии, чтобы можно было обеспечить гарантированный верхний предел усредненной стоимости одной операции(общей стоимости всех операций, разделенной на количество операций).
		// Отимизационный подход заключается в обеспечении гарантированной производительности каждой операции.
		
		// 13.1 Рандомизованные BST-деревья
		// Идея весьма проста: при вставке нового узла в дерево, состоящее из N узлов, вероятность появления нового узла в корне должна быть равна 1/(N + 1), поэтому мы просто принимаем рандомизованное решение использовать вставку в корень с этой вероятностью.
		// В противном случае мы рекурсивно используем метод для вставки новой записи в левое поддерево, если ключ записи меньше ключа в корне, и в правое поддерево — если он больше.
		// Лемма 13.1 Построение рандомизованного BST-дерева эквивалентно построению стандартного BST-дерева из случайно переставленных в исходном состоянии ключей.
		// Для конструирования рандомизованного BST-дерева из N элементов используется около 2*N*ln(N) сравнений(независимо от порядка вставки элементов), а для выполнения поиска в таком дереве требуется приблизительно 2*ln(N) сравнений.
		// Лемма 13.2 Вероятность того, что затраты на создание рандомизованного BST-depeea превышают усредненные затраты в A раз, меньше е^(-A).
		// Один из главных недостатков рандомизованной вставки — затраты на генерацию случайных чисел в каждом из узлов во время каждой вставки.
		// Еще один потенциальный недостаток рандомизованных BST-деревьев — необходимость наличия в каждом узле поля количества узлов поддерева данного узла.
		// Основной принцип сохранения случайной структуры деревьев ведет также к эффективным реализациям операций remove, join и других операций для АТД таблицы символов, обеспечивая при этом создание рандомизованных деревьев.
		// Для объединения дерева, состоящего из N узлов, с деревом, состоящим из M узлов, используется базовый метод, описанный в главе 12, за исключением принятия рандомизованного решения о выборе корня исходя из того, что корень объединенного дерева должен выбираться из N-узлового дерева с вероятностью N /(М + N), а из M-узлового дерева — с вероятностью М / (М + N).
		// Аналогично, произвольное решение заменяется рандомизованным в алгоритме remove, как показано в программе 13.4.
		// Лемма 13.3 Создание дерева через произвольную последовательность рандомизованных операций вставки, удаления и объединения эквивалентно построению стандартного BST-дерева за счет случайной перестановки ключей в дереве.
		
		// 13.2 Расширенные деревья бинарного поиска 
		// Вместо того чтобы рассматривать (рекурсивно) единственную ротацию, которая перемещает недавно вставленный узел к вершине дерева, рассмотрим две ротации, которые перемещают узел из позиции в одном из дочерних узлов корня к вершине дерева.
		// Вначале выполняется одна ротация, которая сделает узел дочерним узлом корня.
		// Затем при помощи еще одной ротации он перемещается в корень.
		// Вставка со скосом (splay insertion) перемещает вновь вставленные узлы в корень за счет применения трансформаций(стандартной вставки в корень, когда связи от корня к дочернему узлу в пути поиска имеют различную ориентацию) и (двух ротаций в корне, когда связи от корня к дочернему узлу в пути поиска имеют одинаковую ориентацию).
		// Построенные таким образом BST-деревья являются расширенными BST-деревъями.
		// Различие между вставкой с расши- В этом простом дереве (вверху) рением и стандартной вставкой в корень может показаться несущественным, но оно достаточно важно:
		// расширение исключает худший случай квадратичной зависимости времени выполнения, являющийся главным недостатком стандартных BST - деревьев.
		// Программа проверяет четыре варианта для двух шагов пути поиска от корня и выполняет соответствующие ротации:
		// влево - влево: дважды выполняет ротацию влево в корне;
		// влево - вправо: выполняет ротацию влево в левом дочернем узле, а затем вправо в корне;
		// вправо - вправо: дважды выполняет ротацию вправо в корне;
		// вправо - влево: выполняет ротацию вправо в правом дочернем узле, а затем ротацию влево в корне.
		// Лемма 13.4 Количество сравнений, используемых при построении расширенного дерева путем N вставок в первоначально пустое дерево, равно O(N*lg(N)).
		// Лемма 13.5 Количество сравнений, требуемых для любой последовательности М операций вставки или поиска в N - узловом расширенном BST - дереве, равно
		// О((N + М)*lg(M + N)).

		// 13.3 Нисходящие 2-3-4-деревья 
		// Определение 13.1 2-3-4-дерево поиска — это либо пустое дерево, либо дерево, содержащее три типа узлов:
		// - 2 - узлы с одним ключом, левой связью к дереву с меньшими ключами и правой связью к дереву с большими ключами;
		// - 3 - узлы с двумя ключами, с левой связью к дереву с меньшими ключами, средней связью к дереву, значения ключей которых лежат между значениями ключей данного узла, и правой связью к дереву с большими ключами;
		// - 4 - узлы с тремя ключами и четырьмя связями к деревьям, значения ключей которых определены диапазонами, образованными ключами узла.
		// Определение 13.2 Сбалансированное 2-3-4-дерево поиска — это 2-3-4-дерево поиска, все пустые деревья которого расположены на одинаковом расстоянии от корня.
		// Лемма 13.6 При поиске в N-узловых 2-3-4-деревьях посещаются максимум lgN + 1 узлов.
		// Лемма 13.7 Для вставок в N-узловых 2-3-4-деревьях в худшем случае требуется разделение менее lg N + 1 узлов, а в среднем, вероятно, потребуется менее одного разделения узла.
		
		// 13.4 Красно-черные деревья, или RB-деревья 
		// Основная идея заключается в представлении 2-3-4-деревьев в виде стандартных BST-деревьев(содержащих только 2 - узлы), но с добавлением к каждому узлу дополнительного информационного разряда для кодирования 3 - узлов и 4 - узлов.
		// Мы будем представлять связи двумя различными типам связей : красными(red) связями(R - связями), которые объединяют воедино небольшие бинарные деревья, образующие 3 - узлы и 4 - узлы, и черными(black) связями(В - связями), которые объединяют воедино 2 - 3 - 4 - дерево.
		// В любом дереве каждый узел указывается одной связью, поэтому окрашивание связей эквивалентно окрашиванию узлов.
		// 2-3-4-деревья, представленные таким образом, называются красно - черными(или RB - ) деревьями бинарного поиска.
		// RB-деревья обладают двумя важными свойствами:
		// - стандартный метод search для BST - деревьев работает безо всяких изменений;
		// - существует прямое соответствие между RB - деревьями и 2 - 3 - 4 - деревьями, поэтому алгоритм с использованием сбалансированного 2 - 3 - 4 - дерева можно реализовать, сохранив соответствие.
		// дополнительные затраты, связанные со вставкой, невелики:
		// действия по балансировке приходится предпринимать только при встрече 4 - узлов, а в дереве количество таких узлов невелико, поскольку они всегда разделяются.
		// Внутренним циклом процедуры вставки является код, выполняющий прохождение вниз по дереву(аналогичный операциям вставки или поиска и вставки в стандартных BST - деревьях), с добавлением одной дополнительной проверки: если узел имеет два дочерних R - узла, он является частью 4 - узла.
		// Столь небольшая перегрузка — основной фактор, определяющий эффективность RB - деревьев бинарного поиска.
		// В RB-дереве операция разделения 4-узла, который не является дочерним 4-узла, реализуется изменение цветов узлов дерева, образующих 4 - узел с последующим возможным выполнением одной или двух ротаций.
		// Лемма 13.8 Для поиска в RB-дереве с N узлами требуется менее 2 lgN + 2 сравнений.
		// Лемма 13.9 Для поиска в RB-дереве с N узлами, построенном из случайных ключей, в среднем используется около 1.002 lgN сравнений.
		// Если в дереве необходимо поддерживать дублированные ключи, то, подобно тому как это делалось в расширенных BST-деревьях, следует разрешить элементам с ключами, равными ключу данного узла, размещаться по обе стороны от этого узла.
		// В противном случае длинные строки дублированных ключей могут привести к серьезному дисбалансу.
		// Старейшая и наиболее изученная структура данных для сбалансированных деревьев — сбалансированное по высоте, или AVL - дерево
		// Определение 13.3 RB-дерево бинарного поиска — это дерево бинарного поиска, в котором каждый узел помечен как красный(R) либо черный(В), с наложением дополнительного ограничения, что никакие два красных узла не могут появляться друг за другом в любом пути от внешней связи к корню.
		// Определение 13.4 Сбалансированное RB-дерево бинарного поиска — это RB-дepeво бинарного поиска, в котором все пути от внешних связей к корню содержат одинаковое количество черных узлов.
		
		// 13.5 Списки пропусков 
		// Подход основан на рандомизованной структуре данных и почти наверняка обеспечивает практически оптимальную производительность всех базовых операций для АТД таблиц символов.
		// Определение 13.5 Список пропусков (skip list — это связный список, в котором каждый узел содержит различное количество связей, причем i - тые связи в узлах реализуют односвязные списки, пропускающие узлы, содержащие менее чем i связей.
		// Лемма 13.10 Для поиска и вставки в рандомизованный список пропусков с параметром t в среднем требуется около(t*log_t(N))/2 = (t/(2lg(t)))*lgN сравнений.
		// Лемма 13.11 Списки пропусков имеют в среднем (t/(t- 1))*N связей.
		
		// 13.6 Характеристики производительности 
		// RB-деревья бинарного поиска привлекательны для библиотечных реализаций таблиц символов, поскольку они обеспечивают гарантированные предельные характеристики производительности для худшего случая и являются наиболее быстрыми алгоритмами поиска и вставки случайных данных.
	}
}

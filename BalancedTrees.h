#pragma once

namespace nsSearch
{
	// Сбалансированные деревья
	namespace nsBalancedTrees
	{
		void main();

		// Описанные в предыдущей главе алгоритмы, использующие деревья бинарного поиска(BST-деревья) успешно работают для широкого множества приложений, однако их производительность существенно снижается в худших случаях.
		// Уже упорядоченные файлы, файлы с большим количеством дублированных ключей, упорядоченные в обратном порядке файлы или файлы с любым большим сегментом, имеющим простую структуру, могут приводить к тому, что время построения BST-дерева определяется квадратичной, а время поиска — линейной зависимостью.
		// Один из подходов к повышению степени сбалансированности в BST-деревьях связан с периодическим явным выполнением их повторной балансировки.
		// Будут показаны решения этой задачи, являющиеся типичными примерами трех базовых подходов к обеспечению гарантированной производительности при разработке алгоритмов:
		// рандомизации, амортизации и оптимизации.
		// При использовании рандомизованного алгоритма принятие случайного решения встроено в сам алгоритм, что радикально уменьшает вероятность возникновения худшего случая сценария(независимо от входного массива данных).
		// Амортизационный подход заключается в однократном выполнении дополнительных действий во избежание выполнения большего объема работы впоследствии, чтобы можно было обеспечить гарантированный верхний предел усредненной стоимости одной операции(общей стоимости всех операций, разделенной на количество операций).
		// Отимизационный подход заключается в обеспечении гарантированной производительности каждой операции.
		
		// 13.1 Рандомизованные BST-деревья
		// Идея весьма проста: при вставке нового узла в дерево, состоящее из N узлов, вероятность появления нового узла в корне должна быть равна 1/(N + 1), поэтому мы просто принимаем рандомизованное решение использовать вставку в корень с этой вероятностью.
		// В противном случае мы рекурсивно используем метод для вставки новой записи в левое поддерево, если ключ записи меньше ключа в корне, и в правое поддерево — если он больше.
		// Лемма 13.1 Построение рандомизованного BST-дерева эквивалентно построению стандартного BST-дерева из случайно переставленных в исходном состоянии ключей.
		// Для конструирования рандомизованного BST-дерева из N элементов используется около 2*N*ln(N) сравнений(независимо от порядка вставки элементов), а для выполнения поиска в таком дереве требуется приблизительно 2*ln(N) сравнений.
		// Лемма 13.2 Вероятность того, что затраты на создание рандомизованного BST-depeea превышают усредненные затраты в A раз, меньше е^(-A).
		// Один из главных недостатков рандомизованной вставки — затраты на генерацию случайных чисел в каждом из узлов во время каждой вставки.
		// Еще один потенциальный недостаток рандомизованных BST-деревьев — необходимость наличия в каждом узле поля количества узлов поддерева данного узла.
		// Основной принцип сохранения случайной структуры деревьев ведет также к эффективным реализациям операций remove, join и других операций для АТД таблицы символов, обеспечивая при этом создание рандомизованных деревьев.
		// Для объединения дерева, состоящего из N узлов, с деревом, состоящим из M узлов, используется базовый метод, описанный в главе 12, за исключением принятия рандомизованного решения о выборе корня исходя из того, что корень объединенного дерева должен выбираться из N-узлового дерева с вероятностью N /(М + N), а из M-узлового дерева — с вероятностью М / (М + N).
		// Аналогично, произвольное решение заменяется рандомизованным в алгоритме remove, как показано в программе 13.4.
		// Лемма 13.3 Создание дерева через произвольную последовательность рандомизованных операций вставки, удаления и объединения эквивалентно построению стандартного BST-дерева за счет случайной перестановки ключей в дереве.
		
		// 13.2 Расширенные деревья бинарного поиска 
		// Вместо того чтобы рассматривать (рекурсивно) единственную ротацию, которая перемещает недавно вставленный узел к вершине дерева, рассмотрим две ротации, которые перемещают узел из позиции в одном из дочерних узлов корня к вершине дерева.
		// Вначале выполняется одна ротация, которая сделает узел дочерним узлом корня.
		// Затем при помощи еще одной ротации он перемещается в корень.
		// Вставка со скосом (splay insertion) перемещает вновь вставленные узлы в корень за счет применения трансформаций(стандартной вставки в корень, когда связи от корня к дочернему узлу в пути поиска имеют различную ориентацию) и (двух ротаций в корне, когда связи от корня к дочернему узлу в пути поиска имеют одинаковую ориентацию).
		// Построенные таким образом BST-деревья являются расширенными BST-деревъями.
		// Различие между вставкой с расши- В этом простом дереве (вверху) рением и стандартной вставкой в корень может показаться несущественным, но оно достаточно важно:
		// расширение исключает худший случай квадратичной зависимости времени выполнения, являющийся главным недостатком стандартных BST - деревьев.
		// Программа проверяет четыре варианта для двух шагов пути поиска от корня и выполняет соответствующие ротации:
		// влево - влево: дважды выполняет ротацию влево в корне;
		// влево - вправо: выполняет ротацию влево в левом дочернем узле, а затем вправо в корне;
		// вправо - вправо: дважды выполняет ротацию вправо в корне;
		// вправо - влево: выполняет ротацию вправо в правом дочернем узле, а затем ротацию влево в корне.
		// Лемма 13.4 Количество сравнений, используемых при построении расширенного дерева путем N вставок в первоначально пустое дерево, равно O(N*lg(N)).
		// Лемма 13.5 Количество сравнений, требуемых для любой последовательности М операций вставки или поиска в N - узловом расширенном BST - дереве, равно
		// О((N + М)*lg(M + N)).

		// 13.3 Нисходящие 2-3-4-деревья 
		// ...540
	}
}

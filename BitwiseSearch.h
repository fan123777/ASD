#pragma once

namespace nsSearch
{
	// Поразрядный поиск 
	namespace nsBitwiseSearch
	{
		void main();

		// В нескольких методах поиска обработка ведется за счет исследования ключей поиска по небольшим фрагментам за раз вместо того, чтобы на каждом шаге сравнивать полные значения ключей.
		// Эти методы носят название поразрядного поиска(radix - search) и работают аналогично методам поразрядной сортировки, которые рассматривались в главе 10.
		// Они удобны, когда фрагменты ключей поискалегкодоступны, и могут обеспечить эффективные решения для множества реальных применений поиска.
		// В данном случае применяется та же абстрактная модель, которая использовалась в главе 10:
		// в зависимости от контекста ключ может быть словом(последовательностью байтов фиксированной длины) или строкой(последовательностью байтов переменной длины).
		// Принципиальные преимущества методов поразрядного поиска заключается в следующем:
		// они обеспечивают приемлемую производительность для худшего случая без сложностей, присущих сбалансированным деревьям;
		// они обеспечивают простой способ обработки ключей переменной длины;
		// некоторые из них позволяют экономить память, сохраняя часть ключа внутри поисковой структуры;
		// они могут обеспечить быстрый доступ к данным, конкурируя как с деревьями бинарного поиска (BST-деревьями), так и с хешированием.
		
		// 15.1 Деревья цифрового поиска 
		// Простейший метод поразрядного поиска основан на использовании деревьев цифрового поиска(digital search trees — DST), на которые в дальнейшем будем ссылаться как на DST - деревья.
		// Алгоритмы поиска и вставки аналогичны поиску в бинарном дереве, за исключением одного различия:
		// ветвление в дереве выполняется не в соответствии с результатом сравнения полных ключей, а в соответствии с выбранными разрядами ключа.
		// На первом уровне используется ведущий разряд;
		// на втором уровне используется разряд, следующий за ведущим, и т.д., пока не встретится внешний узел.
		// DST-деревья характеризуются тем, что каждый ключ размещается где - то вдоль пути, определенного разрядами ключа(следующими слева направо).
		// Этого свойства достаточно, чтобы реализации операций search и insert в программе 15.1 работали правильно.
		// Лемма 15.1 Для выполнения поиска или вставки в DST-дереве, построенном из N случайных ключей, требуется около lg(N) сравнений в среднем и около 2*lg(N) сравнений вхудшем случае.
		// Количество сравнений никогда не превышает количество разрядов в ключе поиска.
		
		// 15.2 Trie-деревья 
		// Основная идея заключается в хранении ключей только в нижней части дерева, в листьях.
		// повсеместно используется термин trie-дерево и все его понимают.
		// В trie-дереве ключи хранятся в листьях бинарного дерева.
		// Вспомните из раздела 5.4, что лист в дереве — это узел, не имеющий дочерних узлов, что отличает его от внешнего узла, который интерпретируется как нулевой дочерний узел.
		// Определение 15.1 Под trie-деревом понимается бинарное дерево, имеющее ключи, связанные с каждым из его листьев, и рекурсивно определенное следующим образом.
		// Trie-дерево, состоящее из пустого набора ключей, представляет собой нулевую связь.
		// Trie-дерево, состоящее из единственного ключа — это лист, содержащий данный ключ.
		// И, наконец, trie - дерево, содержащее намного больше одного ключа — это внутренний узел, левая связь которого ссылается на trie - дерево с ключами, начинающимися с 0 разряда, а правая — на trie - дерево с ключами, начинающимися с 1 разряда, причем для конструирования поддеревьев ведущий разряд такого дерева должен быть удален.
		// Лемма 15.2 Структура trie-дерева не зависит от порядка вставки ключей : для каждого данного набора различных ключей существует уникальное trie-дерево.
		// Лемма 15.3. Для выполнения вставки или поиска случайного ключа в trie-дереве, построенном из N случайных(различных) строк разрядов, требуется в среднем около lgN сравнений разрядов.
		// В худшем случае количество сравнений разрядов не превышает количество разрядов в искомом ключе.
		// Исследование самого рекуррентного соотношения позволяет понять, почему trie - деревья лучше сбалансированы, чем BST - деревья:
		// вероятность того, что разделение произойдет вблизи середины дерева, гораздо выше, чем в любом другом месте.
		// Лемма 15.4 Trie-дерево, построенное из N случайных w-разрядных ключей, содержит в среднем около N / ln(2) = 1.44 N узлов.
		
		// 15.3 patricia-деревья 
		// Начиная со структуры данных стандартного trie - дерева, мы избегаем однонаправленного ветвления благодаря применению простого приема:
		// в каждый узел помещается индекс разряда, который должен проверяться с целью выбора пути из этого узла.
		// Более того, внешние узлы исключаются при помощи еще одного простого приема:
		// данные хранятся во внутренних узлах, а связи с внешними узлами заменяются связями, которые указывают в обратном направлении вверх на требуемый внутренний узел в trie - дереве.
		// ...618
	}
}

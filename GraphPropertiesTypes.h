#pragma once

namespace nsAlgorithmsOnGraphs
{
	// Свойства и типы графов
	namespace nsGraphPropertiesTypes
	{
		void main();
		// Задача изучения рабочих характеристик алгоритмов на графах представляет собой достаточно сложную проблему, что можно объяснить следующими причинами:
		// - Стоимость алгоритма зависит не только от свойств множества элементов, но также и от многочисленных свойств соединений(и глобальных свойств графа, обусловленных свойствами соединений).
		// - Трудность разработки точных моделей типов графов, с которыми, возможно, придется столкнуться.
		
		// 17.1. Глоссарий 
		// Определение 17.1. Граф есть некоторое множество вершин и некоторое множество ребер, соединяющих пары различных вершин(одно ребро может соединять максимум одну пару вершин).
		// Мы используем цифры от 0 до V-1 в качестве имен вершин графа, состоящего из V вершин.
		// Основная причина выбора именно этой системы обозначений заключается в том, что мы получаем быстрый доступ к информации, соответствующей каждой вершине, путем индексирования векторов.
		// Далее будем придерживаться соглашения, в соответствии с которым число вершин в заданном графе всегда обозначается через V, а число ребер - через Е.
		// в определении 17.1 использованы два технических упрощения.
		// Во - первых, оно не позволяет дублировать ребра(математики иногда называют такие ребра параллельными(parallel), а граф, который может содержать такие ребра, мулътиграфом(multlgraph)).
		// Во - вторых, оно не допускает ребер, замыкающихся на одну и ту же вершину; такое ребро называются петлей(self-loop).
		// Графы, в которых нет параллельных ребер или петлей, иногда называют простыми графами (simple graph).
		// Свойство 17.1. Граф, состоящий из V вершин, содержит не более V(V- 1)/2 ребер.
		// Эти ограничения не имеют места в условиях существования параллельных ребер:
		// граф, не принадлежащий к категории простейших, может содержать всего лишь две вершины и миллиарды ребер, соединяющие их(или даже одну вершину и миллиарды петель).
		// Математики употребляют термины вершина (vertex) и узел (node) попеременно, но мы  будем главным образом пользоваться термином вершина при обсуждении графов и термином узел при обсуждении представлений графов, например, структур данных в C++.
		// Аналогично, слова дуга (arc), ребро (edge) и связь (link) также широко используются математиками для описания абстракций, предусматривающих соединение двух вершин, однако мы последовательно будем употреблять термин ребро при обсуждении графов и термин связь при обсуждении структур данных в C++.
		// Если имеется ребро, соединяющее две вершины, будем говорить, что обе эти вершины смежные(adjacent) по отношению друг к другу, а ребро инцидентно(incident on) этим вершинам.
		// Степень (degree) вершины есть число ребер, инцидентных этой вершине.
		// Мы употребляем обозначение v - w для обозначения ребра, соединяющего вершины v и w; обозначение w - v представляет собой еще одно возможное обозначение того же ребра.
		// Подграф (subgraph) представляет собой подмножество ребер некоторого графа (и связанных за ними вершин), которые сами образуют граф.
		// По условиям многих вычислительных задач требуется определить на некотором графе подграфы различных типов.
		// Если выделить некоторое подмножество вершин графа и все ребра графа, соединяющие пары вершин этого подмножества, то такое подмножество называется индуцированным подграфом(induced subgraph), ассоциированным с этими вершинами.
		// Перенесение вершин заданного графа на плоскость и вычерчивание этих вершин и соединяющих их ребер позволяет получить чертеж графа(graph drawing).
		// Планарный граф(planar graph) принадлежит к числу тех, которые можно построить без пересечения ребер.
		// В некоторых приложениях, например, выполняющих анализ географических карт или электрических схем, для построения чертежа графа требуется обширная информационная база, поскольку их вершины соответствуют точкам на плоскости, а расстояния между ними должны быть выдержаны в определенном масштабе.
		// Мы называем такие графы эвклидовыми(Euclidean graph).
		// Два графа называются изоморфными (isomorphic), если можно поменять метки вершин на одном из них таким образом, чтобы набор ребер этого графа стал идентичным набору ребер другого графа.
		// существует V! способов обозначения вершин, т.е.их слишком много, чтобы перепробовать каждый из них.
		// Определение 17.2. Путь (path) в графе есть последовательность вершин, в которой каждая следующая вершина (после первой), является смежной с предыдущей вершиной на этом пути.
		// Все вершины и ребра, составляющие простой путь, различны.
		// Циклом(cycle) называется простой путь, у которого первая и последняя вершина одна и та же.
		// Иногда мы используем термин циклический путь (cyclic path) для обозначения пути, у которого первая и последняя вершина одна и та же(и который в других отношениях не обязательно является простым);
		// мы также употребляем термин контур(tour) для обозначения циклического пути, который включает каждую вершину.
		// По определению длина (length) пути или цикла представляет собой количество образующих их ребер.
		// Мы называем два простых пути непересекающимися (disjoint), если они не содержат общих вершин, кроме, разве что, их конечных точек.
		// Иногда используется термин непересекающиеся по вершинам (vertex disjoint), чтобы отличить эту ситуацию от более сильного условия непересекающиеся по ребрам(edge disjoint), когда мы требуем, чтобы пути не имели общих ребер.
		// Определение 17.3. Граф называется связным графом (connected graph), если существует путь из каждой вершины в любую другую вершину графа.Несвязный граф состоит из некоторого множества связных компонент, которые представляют собой максимальные связные подграфы.
		// Термин максимальный связный подграф (maximal connected subgraph) означает, что не существует пути из вершины такого подграфа в любую другую вершину графа, который не содержался бы в подграфе.
		// Определение 17.4. Ациклический связный граф называется деревом (tree) (см. главу 5). 
		// Множество деревьев называется лесом(forest).
		// Остовное дерево(spanning tree) связного графа есть подграф, который содержит все вершины этого графа и представляет собой единое дерево.
		// Остовный лес(spanning forest) графа есть подграф, который содержит все вершины этого графа и при этом является лесом.
		// граф G с V вершинами есть дерево тогда и только тогда, когда он удовлетворяет одному из четырех условий:
		// - G содержит V - 1 ребро и ни одного цикла.
		// - G содержит V— 1 ребро и представляет собой связный граф.
		// - Каждую пару вершин в G соединяет в точности один простой путь.
		// - G представляет собой связный граф, в то же время при удалении любого из ребер он перестает быть связным.
		// Графы, у которых присутствуют все ребра, называются полными графами(complete graph)
		// Мы определяем дополнение(complement) графа G методом построения, взяв для начала полный граф, имеющий то же число вершин, что и исходный графа G, и удалив из него все ребра графа G.
		// Объединением (union) двух графов является граф, порожденный объединением множеств ребер этих графов.
		// Объединение графа и его дополнения есть полный граф.
		// Общее число различных графов с V вершинами равно 2^(V(V-1) / 2) (число различных способов выбора подмножеств из V(V - 1) / 2 возможных ребер).
		// Полный подграф называется кликой(clique).
		// положим насыщенность (density) графа равной среднему значению степеней его вершин, т.е. 2*E / V.
		// Насыщенный граф есть граф, средняя степень вершин которого пропорциональна V;
		// разреженный граф (sparse graph) есть граф, дополнение которого насыщено.
		// ...28
	}
}

#pragma once

#include "Graph.h"

namespace nsAlgorithmsOnGraphs
{
	// Свойства и типы графов
	namespace nsGraphPropertiesTypes
	{
		void main();

		// Программа, 17.6.Пример клиентской программы обработки графов
		void program17_6();


		// Задача изучения рабочих характеристик алгоритмов на графах представляет собой достаточно сложную проблему, что можно объяснить следующими причинами:
		// - Стоимость алгоритма зависит не только от свойств множества элементов, но также и от многочисленных свойств соединений(и глобальных свойств графа, обусловленных свойствами соединений).
		// - Трудность разработки точных моделей типов графов, с которыми, возможно, придется столкнуться.
		
		// 17.1. Глоссарий 
		// Определение 17.1. Граф есть некоторое множество вершин и некоторое множество ребер, соединяющих пары различных вершин(одно ребро может соединять максимум одну пару вершин).
		// Мы используем цифры от 0 до V-1 в качестве имен вершин графа, состоящего из V вершин.
		// Основная причина выбора именно этой системы обозначений заключается в том, что мы получаем быстрый доступ к информации, соответствующей каждой вершине, путем индексирования векторов.
		// Далее будем придерживаться соглашения, в соответствии с которым число вершин в заданном графе всегда обозначается через V, а число ребер - через Е.
		// в определении 17.1 использованы два технических упрощения.
		// Во - первых, оно не позволяет дублировать ребра(математики иногда называют такие ребра параллельными(parallel), а граф, который может содержать такие ребра, мулътиграфом(multlgraph)).
		// Во - вторых, оно не допускает ребер, замыкающихся на одну и ту же вершину; такое ребро называются петлей(self-loop).
		// Графы, в которых нет параллельных ребер или петлей, иногда называют простыми графами (simple graph).
		// Свойство 17.1. Граф, состоящий из V вершин, содержит не более V(V- 1)/2 ребер.
		// Эти ограничения не имеют места в условиях существования параллельных ребер:
		// граф, не принадлежащий к категории простейших, может содержать всего лишь две вершины и миллиарды ребер, соединяющие их(или даже одну вершину и миллиарды петель).
		// Математики употребляют термины вершина (vertex) и узел (node) попеременно, но мы  будем главным образом пользоваться термином вершина при обсуждении графов и термином узел при обсуждении представлений графов, например, структур данных в C++.
		// Аналогично, слова дуга (arc), ребро (edge) и связь (link) также широко используются математиками для описания абстракций, предусматривающих соединение двух вершин, однако мы последовательно будем употреблять термин ребро при обсуждении графов и термин связь при обсуждении структур данных в C++.
		// Если имеется ребро, соединяющее две вершины, будем говорить, что обе эти вершины смежные(adjacent) по отношению друг к другу, а ребро инцидентно(incident on) этим вершинам.
		// Степень (degree) вершины есть число ребер, инцидентных этой вершине.
		// Мы употребляем обозначение v - w для обозначения ребра, соединяющего вершины v и w; обозначение w - v представляет собой еще одно возможное обозначение того же ребра.
		// Подграф (subgraph) представляет собой подмножество ребер некоторого графа (и связанных за ними вершин), которые сами образуют граф.
		// По условиям многих вычислительных задач требуется определить на некотором графе подграфы различных типов.
		// Если выделить некоторое подмножество вершин графа и все ребра графа, соединяющие пары вершин этого подмножества, то такое подмножество называется индуцированным подграфом(induced subgraph), ассоциированным с этими вершинами.
		// Перенесение вершин заданного графа на плоскость и вычерчивание этих вершин и соединяющих их ребер позволяет получить чертеж графа(graph drawing).
		// Планарный граф(planar graph) принадлежит к числу тех, которые можно построить без пересечения ребер.
		// В некоторых приложениях, например, выполняющих анализ географических карт или электрических схем, для построения чертежа графа требуется обширная информационная база, поскольку их вершины соответствуют точкам на плоскости, а расстояния между ними должны быть выдержаны в определенном масштабе.
		// Мы называем такие графы эвклидовыми(Euclidean graph).
		// Два графа называются изоморфными (isomorphic), если можно поменять метки вершин на одном из них таким образом, чтобы набор ребер этого графа стал идентичным набору ребер другого графа.
		// существует V! способов обозначения вершин, т.е.их слишком много, чтобы перепробовать каждый из них.
		// Определение 17.2. Путь (path) в графе есть последовательность вершин, в которой каждая следующая вершина (после первой), является смежной с предыдущей вершиной на этом пути.
		// Все вершины и ребра, составляющие простой путь, различны.
		// Циклом(cycle) называется простой путь, у которого первая и последняя вершина одна и та же.
		// Иногда мы используем термин циклический путь (cyclic path) для обозначения пути, у которого первая и последняя вершина одна и та же(и который в других отношениях не обязательно является простым);
		// мы также употребляем термин контур(tour) для обозначения циклического пути, который включает каждую вершину.
		// По определению длина (length) пути или цикла представляет собой количество образующих их ребер.
		// Мы называем два простых пути непересекающимися (disjoint), если они не содержат общих вершин, кроме, разве что, их конечных точек.
		// Иногда используется термин непересекающиеся по вершинам (vertex disjoint), чтобы отличить эту ситуацию от более сильного условия непересекающиеся по ребрам(edge disjoint), когда мы требуем, чтобы пути не имели общих ребер.
		// Определение 17.3. Граф называется связным графом (connected graph), если существует путь из каждой вершины в любую другую вершину графа.Несвязный граф состоит из некоторого множества связных компонент, которые представляют собой максимальные связные подграфы.
		// Термин максимальный связный подграф (maximal connected subgraph) означает, что не существует пути из вершины такого подграфа в любую другую вершину графа, который не содержался бы в подграфе.
		// Определение 17.4. Ациклический связный граф называется деревом (tree) (см. главу 5). 
		// Множество деревьев называется лесом(forest).
		// Остовное дерево(spanning tree) связного графа есть подграф, который содержит все вершины этого графа и представляет собой единое дерево.
		// Остовный лес(spanning forest) графа есть подграф, который содержит все вершины этого графа и при этом является лесом.
		// граф G с V вершинами есть дерево тогда и только тогда, когда он удовлетворяет одному из четырех условий:
		// - G содержит V - 1 ребро и ни одного цикла.
		// - G содержит V— 1 ребро и представляет собой связный граф.
		// - Каждую пару вершин в G соединяет в точности один простой путь.
		// - G представляет собой связный граф, в то же время при удалении любого из ребер он перестает быть связным.
		// Графы, у которых присутствуют все ребра, называются полными графами(complete graph)
		// Мы определяем дополнение(complement) графа G методом построения, взяв для начала полный граф, имеющий то же число вершин, что и исходный графа G, и удалив из него все ребра графа G.
		// Объединением (union) двух графов является граф, порожденный объединением множеств ребер этих графов.
		// Объединение графа и его дополнения есть полный граф.
		// Общее число различных графов с V вершинами равно 2^(V(V-1) / 2) (число различных способов выбора подмножеств из V(V - 1) / 2 возможных ребер).
		// Полный подграф называется кликой(clique).
		// положим насыщенность (density) графа равной среднему значению степеней его вершин, т.е. 2*E / V.
		// Насыщенный граф есть граф, средняя степень вершин которого пропорциональна V;
		// разреженный граф (sparse graph) есть граф, дополнение которого насыщено.
		// Информация о том, с каким графом мы имеем дело, с плотным или разреженным, в общем случае является ключевым фактором выбора эффективного алгоритма обработки графа.
		// общем случае для практических целей вполне дос таточно терминов разреженный(sparse) и насыщенный(dense), чтобы можно было получить представление об основных рабочих характеристиках требуемых алгоритмов.
		// Как правило, число ребер намного превосходит число вершин(VIЕнамного меньше 1).
		// Двухдольный граф (bipartite graph) есть граф, множество вершин которого можно разделить на такие два подмножества, что любое ребро соединяют вершину одного подмножества только с вершиной другого подмножества.
		// Графы, которые мы рассматривали до сих пор, носят название неориентированных графов(undirected graphs)
		// В ориентированных графах (directed graphs), известных еще как орграфы (orgcaph), ребра однонаправленные:
		// мы рассматриваем пару вершин, определяющую конкретное ребро, как упорядоченную(ordered) пару, которая определяет однонаправленную смежность в том смысле, что возможность перехода из первой вершины во вторую отнюдь не означает переход из второй вершины в первую.
		// Ребра в орфафах мы называем ориентированными ребрами(directed edges), хотя в общем случае это свойство вытекает из контекста(некоторые авторы для обозначения ориентированных ребер применяют термин дуга(arc)).
		// Первая вершина ориентированного ребра называется началом(source), вторая вершина называется концом (destination).
		// Некоторые авторы употребляют, соответственно, термины хвост(tail) и голова(head)
		// Когда мы используем обозначение w-v по отношению к орфафу, мы делаем это с целью показать, что ребро, которое исходит из w и заходит в v, отличается от ребра v - w, которое исходит из v и заходит в w.
		// Мы также говорим о полустепени исхода(outdegree) и полустепени захода (indegree) некоторой вершины(соответственно, число ребер, для которых она служит началом, и число ребер, для которых она служит концом).
		// Направленный цикл(directed cycle) в орграфе - это цикл, в котором пары смежных вершин появляются в порядке, указанном(устанавливаемом) ребрами графа.
		// Граф DAG (Directed Acyclic Graph - ориентированный ациклический граф) есть орграф, который не содержит направленных циклов.
		// В случае взвешенного графа (weighted graph) с каждым ребром мы связываем числа(weights - веса), которые в общем случае представляют собой расстояние либо стоимость.
		// В главе 20 мы будем изучать взвешенные неориентированные графы, которые мы обычно называем сетями(networks).
		// Алгоритмы в главе 22 решают классические задачи, которые возникают в конкретных интерпретациях сетей, известных как транспортные сети(flow network).
		
		// 17.2. АТД графа 
		// В некоторых ситуациях целесообразно включить функцию АТД удалить параллельные ребра(remove parallel edges).
		// В общем случае задачи обработки графов, которые исследуются в этой книге, подразделяются на три обширных категории:
		// - Вычисления значений некоторых размеров графа.
		// - Выбор некоторого подмножества ребер графа.
		// - Ответы на вопросы, касающиеся некоторых свойств графа.
		// Примеры, относящиеся к первой категории, суть количество связных компонент и длина кратчайшего пути между двумя заданными вершинами графа;
		// примеры, относящиеся ко второй категории, связаны с остовным деревом и циклом наибольшей длины, который содержит заданную вершину; примеры третьей категории составляют вопросы наподобие:
		// находятся ли заданные вершины в одной и той же компоненте.
		// Динамические задачи, в рамках которых мы хотим совместить обработку графов с добавлением или удалением вершин и ребер графа, приводят нас в область интерактивных алгоритмов(on - line algorithm), известных также как динамические алгоритмы(dynamic algorithms), в которой приходится сталкиваться с другими сложными проблемами.
		// в виде матриц смежности(adjacency - matrix) и в виде списков смежных вершин(adjacency - list) графа.
		
		// 17.3.Представление графа в виде матрицы смежности
		// ...33
	}
}

#pragma once

namespace nsAlgorithmsOnGraphs
{
	// Свойства и типы графов
	namespace nsGraphPropertiesTypes
	{
		void main();

		// Программа, 17.6.Пример клиентской программы обработки графов
		void program17_6();
		void test();

		// Задача изучения рабочих характеристик алгоритмов на графах представляет собой достаточно сложную проблему, что можно объяснить следующими причинами:
		// - Стоимость алгоритма зависит не только от свойств множества элементов, но также и от многочисленных свойств соединений(и глобальных свойств графа, обусловленных свойствами соединений).
		// - Трудность разработки точных моделей типов графов, с которыми, возможно, придется столкнуться.
		
		// 17.1. Глоссарий 
		// Определение 17.1. Граф есть некоторое множество вершин и некоторое множество ребер, соединяющих пары различных вершин(одно ребро может соединять максимум одну пару вершин).
		// Мы используем цифры от 0 до V-1 в качестве имен вершин графа, состоящего из V вершин.
		// Основная причина выбора именно этой системы обозначений заключается в том, что мы получаем быстрый доступ к информации, соответствующей каждой вершине, путем индексирования векторов.
		// Далее будем придерживаться соглашения, в соответствии с которым число вершин в заданном графе всегда обозначается через V, а число ребер - через Е.
		// в определении 17.1 использованы два технических упрощения.
		// Во - первых, оно не позволяет дублировать ребра(математики иногда называют такие ребра параллельными(parallel), а граф, который может содержать такие ребра, мулътиграфом(multlgraph)).
		// Во - вторых, оно не допускает ребер, замыкающихся на одну и ту же вершину; такое ребро называются петлей(self-loop).
		// Графы, в которых нет параллельных ребер или петлей, иногда называют простыми графами (simple graph).
		// Свойство 17.1. Граф, состоящий из V вершин, содержит не более V(V- 1)/2 ребер.
		// Эти ограничения не имеют места в условиях существования параллельных ребер:
		// граф, не принадлежащий к категории простейших, может содержать всего лишь две вершины и миллиарды ребер, соединяющие их(или даже одну вершину и миллиарды петель).
		// Математики употребляют термины вершина (vertex) и узел (node) попеременно, но мы  будем главным образом пользоваться термином вершина при обсуждении графов и термином узел при обсуждении представлений графов, например, структур данных в C++.
		// Аналогично, слова дуга (arc), ребро (edge) и связь (link) также широко используются математиками для описания абстракций, предусматривающих соединение двух вершин, однако мы последовательно будем употреблять термин ребро при обсуждении графов и термин связь при обсуждении структур данных в C++.
		// Если имеется ребро, соединяющее две вершины, будем говорить, что обе эти вершины смежные(adjacent) по отношению друг к другу, а ребро инцидентно(incident on) этим вершинам.
		// Степень (degree) вершины есть число ребер, инцидентных этой вершине.
		// Мы употребляем обозначение v - w для обозначения ребра, соединяющего вершины v и w; обозначение w - v представляет собой еще одно возможное обозначение того же ребра.
		// Подграф (subgraph) представляет собой подмножество ребер некоторого графа (и связанных за ними вершин), которые сами образуют граф.
		// По условиям многих вычислительных задач требуется определить на некотором графе подграфы различных типов.
		// Если выделить некоторое подмножество вершин графа и все ребра графа, соединяющие пары вершин этого подмножества, то такое подмножество называется индуцированным подграфом(induced subgraph), ассоциированным с этими вершинами.
		// Перенесение вершин заданного графа на плоскость и вычерчивание этих вершин и соединяющих их ребер позволяет получить чертеж графа(graph drawing).
		// Планарный граф(planar graph) принадлежит к числу тех, которые можно построить без пересечения ребер.
		// В некоторых приложениях, например, выполняющих анализ географических карт или электрических схем, для построения чертежа графа требуется обширная информационная база, поскольку их вершины соответствуют точкам на плоскости, а расстояния между ними должны быть выдержаны в определенном масштабе.
		// Мы называем такие графы эвклидовыми(Euclidean graph).
		// Два графа называются изоморфными (isomorphic), если можно поменять метки вершин на одном из них таким образом, чтобы набор ребер этого графа стал идентичным набору ребер другого графа.
		// существует V! способов обозначения вершин, т.е.их слишком много, чтобы перепробовать каждый из них.
		// Определение 17.2. Путь (path) в графе есть последовательность вершин, в которой каждая следующая вершина (после первой), является смежной с предыдущей вершиной на этом пути.
		// Все вершины и ребра, составляющие простой путь, различны.
		// Циклом(cycle) называется простой путь, у которого первая и последняя вершина одна и та же.
		// Иногда мы используем термин циклический путь (cyclic path) для обозначения пути, у которого первая и последняя вершина одна и та же(и который в других отношениях не обязательно является простым);
		// мы также употребляем термин контур(tour) для обозначения циклического пути, который включает каждую вершину.
		// По определению длина (length) пути или цикла представляет собой количество образующих их ребер.
		// Мы называем два простых пути непересекающимися (disjoint), если они не содержат общих вершин, кроме, разве что, их конечных точек.
		// Иногда используется термин непересекающиеся по вершинам (vertex disjoint), чтобы отличить эту ситуацию от более сильного условия непересекающиеся по ребрам(edge disjoint), когда мы требуем, чтобы пути не имели общих ребер.
		// Определение 17.3. Граф называется связным графом (connected graph), если существует путь из каждой вершины в любую другую вершину графа.Несвязный граф состоит из некоторого множества связных компонент, которые представляют собой максимальные связные подграфы.
		// Термин максимальный связный подграф (maximal connected subgraph) означает, что не существует пути из вершины такого подграфа в любую другую вершину графа, который не содержался бы в подграфе.
		// Определение 17.4. Ациклический связный граф называется деревом (tree) (см. главу 5). 
		// Множество деревьев называется лесом(forest).
		// Остовное дерево(spanning tree) связного графа есть подграф, который содержит все вершины этого графа и представляет собой единое дерево.
		// Остовный лес(spanning forest) графа есть подграф, который содержит все вершины этого графа и при этом является лесом.
		// граф G с V вершинами есть дерево тогда и только тогда, когда он удовлетворяет одному из четырех условий:
		// - G содержит V - 1 ребро и ни одного цикла.
		// - G содержит V— 1 ребро и представляет собой связный граф.
		// - Каждую пару вершин в G соединяет в точности один простой путь.
		// - G представляет собой связный граф, в то же время при удалении любого из ребер он перестает быть связным.
		// Графы, у которых присутствуют все ребра, называются полными графами(complete graph)
		// Мы определяем дополнение(complement) графа G методом построения, взяв для начала полный граф, имеющий то же число вершин, что и исходный графа G, и удалив из него все ребра графа G.
		// Объединением (union) двух графов является граф, порожденный объединением множеств ребер этих графов.
		// Объединение графа и его дополнения есть полный граф.
		// Общее число различных графов с V вершинами равно 2^(V(V-1) / 2) (число различных способов выбора подмножеств из V(V - 1) / 2 возможных ребер).
		// Полный подграф называется кликой(clique).
		// положим насыщенность (density) графа равной среднему значению степеней его вершин, т.е. 2*E / V.
		// Насыщенный граф есть граф, средняя степень вершин которого пропорциональна V;
		// разреженный граф (sparse graph) есть граф, дополнение которого насыщено.
		// Информация о том, с каким графом мы имеем дело, с плотным или разреженным, в общем случае является ключевым фактором выбора эффективного алгоритма обработки графа.
		// общем случае для практических целей вполне дос таточно терминов разреженный(sparse) и насыщенный(dense), чтобы можно было получить представление об основных рабочих характеристиках требуемых алгоритмов.
		// Как правило, число ребер намного превосходит число вершин(VIЕнамного меньше 1).
		// Двухдольный граф (bipartite graph) есть граф, множество вершин которого можно разделить на такие два подмножества, что любое ребро соединяют вершину одного подмножества только с вершиной другого подмножества.
		// Графы, которые мы рассматривали до сих пор, носят название неориентированных графов(undirected graphs)
		// В ориентированных графах (directed graphs), известных еще как орграфы (orgcaph), ребра однонаправленные:
		// мы рассматриваем пару вершин, определяющую конкретное ребро, как упорядоченную(ordered) пару, которая определяет однонаправленную смежность в том смысле, что возможность перехода из первой вершины во вторую отнюдь не означает переход из второй вершины в первую.
		// Ребра в орфафах мы называем ориентированными ребрами(directed edges), хотя в общем случае это свойство вытекает из контекста(некоторые авторы для обозначения ориентированных ребер применяют термин дуга(arc)).
		// Первая вершина ориентированного ребра называется началом(source), вторая вершина называется концом (destination).
		// Некоторые авторы употребляют, соответственно, термины хвост(tail) и голова(head)
		// Когда мы используем обозначение w-v по отношению к орфафу, мы делаем это с целью показать, что ребро, которое исходит из w и заходит в v, отличается от ребра v - w, которое исходит из v и заходит в w.
		// Мы также говорим о полустепени исхода(outdegree) и полустепени захода (indegree) некоторой вершины(соответственно, число ребер, для которых она служит началом, и число ребер, для которых она служит концом).
		// Направленный цикл(directed cycle) в орграфе - это цикл, в котором пары смежных вершин появляются в порядке, указанном(устанавливаемом) ребрами графа.
		// Граф DAG (Directed Acyclic Graph - ориентированный ациклический граф) есть орграф, который не содержит направленных циклов.
		// В случае взвешенного графа (weighted graph) с каждым ребром мы связываем числа(weights - веса), которые в общем случае представляют собой расстояние либо стоимость.
		// В главе 20 мы будем изучать взвешенные неориентированные графы, которые мы обычно называем сетями(networks).
		// Алгоритмы в главе 22 решают классические задачи, которые возникают в конкретных интерпретациях сетей, известных как транспортные сети(flow network).
		
		// 17.2. АТД графа 
		// В некоторых ситуациях целесообразно включить функцию АТД удалить параллельные ребра(remove parallel edges).
		// В общем случае задачи обработки графов, которые исследуются в этой книге, подразделяются на три обширных категории:
		// - Вычисления значений некоторых размеров графа.
		// - Выбор некоторого подмножества ребер графа.
		// - Ответы на вопросы, касающиеся некоторых свойств графа.
		// Примеры, относящиеся к первой категории, суть количество связных компонент и длина кратчайшего пути между двумя заданными вершинами графа;
		// примеры, относящиеся ко второй категории, связаны с остовным деревом и циклом наибольшей длины, который содержит заданную вершину; примеры третьей категории составляют вопросы наподобие:
		// находятся ли заданные вершины в одной и той же компоненте.
		// Динамические задачи, в рамках которых мы хотим совместить обработку графов с добавлением или удалением вершин и ребер графа, приводят нас в область интерактивных алгоритмов(on - line algorithm), известных также как динамические алгоритмы(dynamic algorithms), в которой приходится сталкиваться с другими сложными проблемами.
		// в виде матриц смежности(adjacency - matrix) и в виде списков смежных вершин(adjacency - list) графа.
		
		// 17.3.Представление графа в виде матрицы смежности
		// Представление матрицы смежности (adjacency-matrix) графа есть матрица булевских значений размерности V на V, элемент которой, стоящий на пересечении v-й строки и w-го столбца принимает значение 1, если в графе имеется ребро, соединяющее вершину v с вершиной и w, и 0 в противном случае.
		// что сохранение этого свойства в неориентированном фафе требуется, чтобы каждое ребро было представлено двумя вхождениями:
		// ребро v-w представлено значением true как для adj[v][w], так и для adj[w][v], что соответствует ребру w-v.
		// Представление графа в виде матрицы смежности не особенно подходит для разреженных графов:
		// нам необходимо V^2 битов памяти и выполнить V^2 действий, чтобы построить такое представление.
		// В насыщенном графе, в котором число ребер(число единичных битов в матрице) пропорционально V^2, такая цена может быть приемлемой, поскольку для обработки ребер понадобится время, пропорциональное V^2, независимо от того, какое представление используется.
		
		// 17.4. Представление графа в виде списка смежных вершин
		// Стандартное представление графа, которому обычно отдают предпочтение, когда граф не относится к числу насыщенных, называется представлением в виде списков смежных вершин(adjacency - lists), в рамках которого мы отслеживаем все вершины, соединенные с каждой вершиной, включенной в связанный список этой вершины.
		// Мы поддерживаем вектор списков, так что достаточно указать вершину, чтобы получить немедленный доступ к ее списку;
		// мы используем связные списки для того, чтобы ввести новое ребро за постоянное время.
		// Основное преимущество представления графа в виде списка смежных вершин перед представлением в виде матрицы смежности заключается в том, что на его реализацию затрачивается пространство памяти, пропорциональное V + Е, а не V^2, как в случае представления в виде матрицы смежности.Основной недостаток этого представления состоит в том, что проверка существования конкретных ребер может потребовать времени, пропорционального V, в противовес постоянному времени в случае матрицы смежности.
		// Эти различия приводят, главным образом, к различию в использовании связных списков и векторов для представления множеств вершин, инцидентных каждой вершине.

		// 17.5.Вариации, расширения и затраты
		// Рассматриваемые вопросы можно разделить на три категории.
		// Во-первых, базовые механизмы матрицы смежности и списков смежных вершин графа допускают расширения, которые позволяют получать представления других типов графов.
		// Во-вторых, мы рассмотрим структуры АТД графа, обладающие большим набором свойств, чем структура, выбранная нами в качестве базовой, и реализации, которые используют более развитые структуры данных с целью построения более совершенных реализаций этих структур.
		// В третьих, мы обсудим принимаемый нами общий подход к решению задач обработки графов, который предусматривает построение классов, инкапсулирующих специфику задач и использующих АТД базовых графов.
		// Для каждой задачи обработки графа из числа рассматриваемых в данной книге мы инкапсулируем ее решение в классах, подобных приведенному, с приватными элементами данных и общедоступными функциями - элементами, специфичными для каждой задачи.
		// обработка графов, намного шире, чем виды базовых структур данных, которые служили объектом анализа в главе 4.
		// Из всего множества этих недостатков в качестве основных выделим следующие:
		// - Существует намного больше подлежащих реализации функций обработки графов, чем те, которые мы можем должным образом определить в одном интерфейсе.
		// - Простые задачи обработки графов должны пользоваться теми же интерфейсами, которые необходимы для решения сложных задач.
		// - Одна функция-элемент может получить доступ к элементам данных, предназначенных для использования другой функцией - элементом вопреки принципам инкапсуляции, которым мы намерены следовать.
		// - Массив ребер
		// - Матрица смежности
		// - Списки смежных вершин
		// В силу того, что некоторые операции используются в типовых приложениях особенно часто, подробно рассмотрим операции find edge(найти ребро) и remove edge(удалить ребро).
		// Например, если мы используем реализации динамической хэш-таблицы (см. раздел 14.5), оба подхода требуют памяти, пропорциональной Е, и позволяют выполнять и ту и другую операции за постоянное время(в среднем, с амортизацией расходов на реализацию).
		// Удаление вершин требует больших затрат.
		// В представлении графа в виде матрицы смежности мы, по существу, должны удалить из матрицы соответствующие строку и столбец, что требует не меньших затрат, чем построение новой матрицы смежности меньшего размера(хотя в этом случае эти издержки можно уменьшить, если воспользоваться темже механизмом, который применяется при работе с динамическими хэш - таблицами).
		// Чтобы больше не останавливаться на этих исключениях, в дальнейшем мы полагаем, что размер представления графа, которое мы используем, пропорционален числу ребер этого графа.
		
		// 17.6. Генераторы графов
		// Мы столкнемся с различными моделями случайных величин, начиная со следующих двух.
		// Случайные ребра.
		// Случайный граф.
		// k-соседний граф. 
		// Эвклидов граф с близкими связями.
		// Граф транзакций.
		// Граф вызовов функций.
		// Мы используем статические графы вызовов функций при изучении структуры программы и динамические графы при изучении поведения программы.
		// Как правило, такие графы принимают большие размеры и относятся к категории разреженных.
		// Граф со степенями разделения.
		// Интервальный граф.
		// Граф Де-Бруйна.

		// 17.7. Простые, эйлеровы и гамильтоновы пути 
		// Простой путь. Если заданы две какие-либо вершины графа, существует ли путь, который их соединяет?
		// В условиях некоторых приложений нам вполне достаточно знать, существует или не существует такой путь, но данном случае наша задача заключается в том, чтобы найти конкретный путь.
		// поиск в глубину(depth - first search)
		// Этот алгоритм построен на базе приватной функции - элемента, которая определяет, существует ли простой путь из вершины v в вершину w путем проверки для каждого ребра v - t инцидентного v, существует ли простой путь из t в w, который не проходит через v.
		// Как следует расширить ее с тем, чтобы она могла печатать ребра, составляющие путь?
		// Рекурсивный подход предлагает простое решение:
		// - Добавить оператор печати ребра v-t сразу же после того, как рекурсивный вызов в функции searchR находит путь из t в w.
		// - В вызове функции searchR из конструктора поменять местами v и w.
		// Свойство 17.2. Мы можем найти путь, соединяющий две заданных вершины графа, за линейное время.
		// Мы используем термин линейный (linear) в контексте алгоритмов на графах, подразумевая под этим, что некоторое количественное значение не превосходит величины V + Е(т.е.размеры графа), умноженной на соответствующий постоянный коэффициент.
		// рассмотрим следующую задачу, в рамках которой мы осуществляем поиск пути, соединяющих пары вершин, но при этом добавляется условие, согласно которому эти пути проходят через все остальные вершины графа.
		// Гамильтонов путь.
		// Пусть даны две вершины, существует ли простой путь, соединяющий эти вершины, который проходит через каждую вершину графа в точности один раз?
		// Свойство 17.3. Рекурсивный поиск гамилыпонова цикла может потребовать экспоненциального времени.
		// Теперь предположим, что мы изменили начальные условия, и требование обязательного обхода всех вершин заменяется требованием обхода всех ребер.
		// Является ли эта задача такой же легкой, как и нахождение простых путей, или безнадежно трудной проблемой, подобной поиску гамильтоновых путей?
		// Эйлеров путь.
		// Существует ли путь, соединяющий две заданных вершины, который проходит через каждое ребро графа в точности один раз?
		// Путь не обязательно должен быть простым - вершины можно посещать многократно.
		// Эйлер нашел легкий способ определить, существует ли такая цепь, для этого достаточно определить степень каждой вершины.
		// Это свойство нетрудно сформулировать и применять, однако его доказательство в теории фафов требует немалой изобретательности.
		// Свойство 17.4.Граф содержит эйлеров цикл тогда и только тогда, когда он связный и все его вершины имеют четную степень.
		// Следствие. Граф содержит эйлеров цикл тогда и только тогда, ^когда он связный и в точности две его вершины имеют нечетную степень.
		// Другой подход вытекает из доказательства свойства 17.4. Проследуем по циклическому пути, стирая все ребра и помещая в стек все вершины, которые нам встретятся, так что(1) мы можем проследить свой путь, распечатав его ребра, и(2) проверить каждую вершину на наличие боковых путей(который может быть включен в главный путь).
		// Свойство 17.5. Мы можем обнаружить в графе эйлеров цикл, если таковой существует, за линейное время.
		// В самом деле, как мы убедимся позже, поиск в глубину на неориентированном графе эквивалентен вычислению двухпроходного эйлерова цикла(two way Euler tour) — пути, который проходит по каждому ребру в точности два раза, по одному в каждом направлении.

		// 17.8 Задачи обработки графов 
		// В этом смысле мы разобьем эти задачи примерно по следующим категориям сложности их решения:
		// - Легкие 
		// - Поддаются решению
		// - Трудно решаемые
		// - Неизвестно, существует ли решение.
		// в главах 18-22 мы рассмотрим множество других таких задач, и в первую очередь следующие.
		// - Простая связность.
		// - Сильная связность в орграфах.
		// - Транзитивное замыкание.
		// - Минимальное остовное дерево.
		// - Поиск кратчайших путей из одного истока.
		// Решения могут оказаться слишком сложным, далее следуют два примера наиболее актуальных задач этого класса.
		// - Планарность.
		// - Сочетания.
		// - Четные циклы в орграфах.
		// Алгоритмы поиска кратчайшего маршрута(shortestpath algorithm), рассматриваемые в главе 21,
		// алгоритмы на транспортных сетях(network flow algorithm), исследуемые в главе 22,
		// а также мощный сетевой симплексный алгоритм(network simplex algorithm), рассматриваемый в главе 22,
		// способны решать многие задачи на графах, которые в противном случае превращаются в трудно преодолимые проблемы.
		// В числе таких задач отметим следующие.
		// - Задача распределения.
		// - Общая связность.
		// - Задача почтальона.
		// Задача обработки графов, неподдающаяся решению (intractable), — это задача, для которой не известен алгоритм, гарантирующий ее решение за приемлемый промежуток времени.
		// - Самый длинный путь.
		// - Задача окраски.
		// - Множество независимых вершин.
		// - Клика.
		// На практике, однако, мы, по существу, часто стремимся отыскать полное решение, которое в общем случае найти гораздо труднее.
		// - теорема четырех красок (four color theorem) утверждает, что можно воспользоваться четырьмя цветами для раскраски всех вершин планарного графа таким образом, что ни одно ребро не будет соединять две вершины одного и того же цвета.
		// - задача коммивояжера (traveling salesperson), по условиям которой требуется определить минимальный путь обхода вершин взвешенного графа.
		// Существуют задачи обработки графов, о которых не известно, насколько они трудны для решения(их трудность неизвестна).
		// Изоморфизм графов.
	}
}

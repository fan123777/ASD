#pragma once

#include "Common.h"
#include "Stack.h"

namespace nsLStack = nsDataStructures::nsAbstractDataTypes::nsListStack;

namespace nsSorting
{
	// Быстрая сортировка
	namespace nsQuickSort
	{
		void main();

		// Программа 7.2.Разделение
		template <class Item>
		int partition(Item a[], int l, int r)
		{
			int i = l - 1, j = r;
			Item v = a[r];
			for (;;)
			{
				while (a[++i] < v);
				while (v < a[--j])
				if (j == l)
					break;
				if (i >= j)
					break;
				nsCommon::exch(a[i], a[j]);
			}
			nsCommon::exch(a[i], a[r]);
			return i;
		}

		// Программа 7.1.Быстрая сортировка
		template <class Item>
		void quicksort(Item a[], int l, int r)
		{
			if (r <= l)
				return;
			int i = partition(a, l, r);
			quicksort(a, l, i - 1);
			quicksort(a, i + 1, r);
		}

		// Программа 7.3.Нерекурсивная программная реализация быстрой сортировки.
		inline void push2(nsLStack::Stack<int>& s, int A, int B)
		{
			s.push(B); s.push(A);
		}

		template <class Item>
		void quicksort2(Item a[], int l, int r)
		{
			nsLStack::Stack<int> s;
			push2(s, l, r);
			while (!s.empty())
			{
				l = s.pop();
				r = s.pop();
				if (r <= l)
					continue;
				int i = partition(a, l, r);
				if (i - 1 > r - i)
				{
					push2(s, l, i - 1);
					push2(s, i + 1, r);
				}
				else
				{
					push2(s, i + 1, r);
					push2(s, l, i - 1);
				}
			}
		}

		// Программа 7.4.Улучшенная быстрая сортировка
		template <class Item>
		void quicksort3(Item a[], int l, int r, int M)
		{
			if (r - l <= M)
				return;

			nsCommon::exch(a[(l + r) / 2], a[r - 1]);
			nsCommon::comexch(a[l], a[r - 1]);
			nsCommon::comexch(a[l], a[r]);
			nsCommon::comexch(a[r - 1], a[r]);
			int i = partition(a, l + 1, r - 1);
			quicksort3(a, l, i - 1, M);
			quicksort3(a, i + 1, r, M);
		}

		template <class Item>
		void hybridsort(Item a[], int l, int r)
		{
			static const int M = 10;
			quicksort3(a, l, r, M);
			nsCommon::insertion(a, l, r);
		}

		// Программа 7.5.Быстрая сортировка с разделением на три части
		template <class Item>
		int operator==(const Item& A, const Item& B)
		{
			return !less(A, B) && !less(B, A);
		}

		template <class Item>
		void quicksort4(Item a[], int l, int r)
		{
			int k; Item v = a[r];
			if (r <= l)
				return;

			int i = l - 1, j = r, p = l - 1, q = r;
			for (;;)
			{
				while (a[++i] < v);
				while (v < a[--j])
				if (j == l)
					break;
				if (i >= j)
					break;
				nsCommon::exch(a[i], a[j]);
				if (a[i] == v)
				{
					p++;
					nsCommon::exch(a[p], a[i]);
				}
				if (v == a[j])
				{
					q--;
					nsCommon::exch(a[q], a[j]);
				}
			}
			nsCommon::exch(a[i], a[r]);
			j = i - 1;
			i = i + 1;
			for (k = l; k <= p; k++, j--)
				exch(a[k], a[j]);
			for (k = r - 1; k >= q; k--, i++)
				exch(a[k], a[i]);
			quicksort4(a, l, j);
			quicksort4(a, i, r);
		}

		// Программа 7.6. Выборка
		template <class Item>
		void select(Item a[], int l, int r, int k)
		{
			if (r <= l)
				return;
			int i = partition(a, l, r);
			if (i > k)
				select(a, l, i - 1, k);
			if (i < k)
				select(a, i + 1, r, k);
		}

		// Программа 7.7. Нерекурсивная выборка
		template <class Item>
		void select1(Item a[], int l, int r, int k)
		{
			while (r > l)
			{
				int i = partition(a, l, r);
				if (i >= k)
					r = i - 1;
				if (i <= k)
					l = i + 1;
			}
		}


		// Алгоритм быстрой сортировки обладает и другими весьма привлекательными особенностями : он принадлежит к категории обменных(in - place) сортировок(т.е., требует всего лишь небольшого вспомогательного стека), на выполнение сортировки N элементов в среднем затрачивается время, пропорциональное N*log(N) и для него характерны исключительно короткие внутренний циклы.
		// Его недостатком является то, что он неустойчив, для его выполнения в наихудшем случае требуется N^2 операций.
		
		// 7.1. Базовый алгоритм
		// Быстрый метод сортировки функционирует по принципу "разделяй и властвуй".
		// Он делит сортируемый массив на две части, затем сортирует эти части независимо друг от друга.
		// - Элемент a[i] для некоторого i занимает свою окончательную позицию в массиве.
		// - Ни один из элементов a[l],..., a[i-1] не превышает a[i].
		// - Ни один из элементов a[i+l],..., а[г] не является меньшим a[i].
		// Полная сортировка достигается путем деления файла на подфайлы с последующим применением к ним этих же методов.
		// Разбиение осуществляется с использованием следующей стратегии.
		// Прежде всего, в качестве разделяющего элемента(partitioning element) произвольно выбирается элемент а[r] - он сразу займет свою окончательную позицию.
		// Далее начинается просмотр с левого конца массива, который продолжается до тех пор, пока не будет найден элемент, превосходящий по значению разделяющий элемент, затем выполняется просмотр, начиная с правого конца массива, который продолжается до тех пор, пока не отыскивается элемент, который по значению меньше разделяющего.
		// Оба элемента, на которых просмотр был прерван, очевидно, находятся не на своих местах в разделенном массиве, и потому они меняются местами.
		// Мы продолжаем дальше в том же духе, пока не убедимся в том, что слева от левого указателя не осталось ни одного элемента, который был бы больше по значению разделяющего, и ни одного элемента справа от правого указателя, которые были бы меньше по значению разделяющего элемента, как показано на следующей диаграмме.
		// Как показано на диаграмме, целесообразно останавливать просмотр слева на элементах, больших или равных разделяющему, а просмотр справа - на элементах, меньших или равных элементу разделения.
		// Когда указатели просмотра пересекаются, все, что необходимо сделать в этом случае - это обменять элемент а[r] с крайним левым элементом правого подфайла(на этот элемент указывает левый указатель).
		// Процесс разделения неустойчив.
		// Наиболее простой способ гарантировать завершение рекурсивной программы заключается в том, что
		// - она не вызывает себя для файлов с размерами 1 и менее
		// - вызывает себя только для файлов, размер которых строго меньше размеров входного файла.
		// Существуют три основных стратегии, которые можно выбрать применительно к ключам, равным разделяющему элементу:
		// - заставить оба указателя останавливаться на таком ключе(как это имеет место в программе 7.2);
		// - заставить один указатель остановиться, а другому позволить продолжать просмотр;
		// - позволить обоим указателям продолжить просмотр.
		// Наилучшей стратегией является останов обоих указателей.
		
		// 7.2. Характеристики производительности быстрой сортировки
		// Лемма 7.1.Быстрая сортировка в наихудшем случае выполняет примерно (N^2)/2 операций сравнения.
		// Лемма 7.2. Быстрая сортировка в среднем выполняет 2N*ln(N) операций сравнения.
		
		// 7.3. Размер стека 
		// Лемма 7.3. Если меньший из двух подфайлов сортируется первым, то стек никогда не содержит более lgN вхождений в случаях, когда для сортировки N файлов применяется быстрая сортировка.
		// Этот метод не обязательно будет работать в по-настоящему рекурсивной реализации, поскольку он зависит от очистки стека по окончании рекурсивной процедуры((end- либо tail-recursion removal)

		// 7.4. Подфайлы небольших размеров
		// Заметное повышение эффективности быстрой сортировки следует из того факта, что рекурсивная программа гарантировано вызывает сама себя для работы со множеством подфайлов небольших размеров.
		// if (r-1 <= M) insertion(а, 1, г);
		// Несколько более простой и чуть более эффективный по сравнению с сортировкой вставками способ обращения с подфайлами небольших размеров по мере их появления состоит в том, чтобы поменять проверку в начале программы на
		// if (r - l <= M) return;
		// Этот метод с большой пользой можно применять всякий раз, когда мы имеем дело с рекурсивным алгоритмом.
		// В силу особенностей рекурсивных алгоритмов можно быть уверенным в том, что все они основную часть своего времени будут заняты решением небольших задач;
		// в любом случае для работы с небольшими файлами в нашем распоряжении имеются алгоритмы "решения в лоб" с низкими непроизводительными затратами.
		// Благодаря такому обстоятельству в общем случае можно улучшить общие показатели производительности с помощью гибридных алгоритмов.
		
		// 7.5 Метод разделения с вычислением медианы из трех элементов
		// Метод медианы из трех элементов повышает эффективность сортировки по трем направлениям.
		// Во - первых, он существенно снижает вероятность возникновения наихудшего случая для любой реальной сортировки.
		// Во-вторых, он устраняет необходимость в служебном ключе в процессе разделения, поскольку для выполнения этой функции вполне достаточно одного элемента из числа тех, которые подвергаются проверке до начала разделения.
		// В-третьих, он уменьшает среднее время выполнения алгоритма примерно на 5 процентов.
		// Сочетание использования метода медианы из трех элементов с отсечением подфайлов небольших размеров может уменьшить среднее время выполнения быстрой сортировки по сравнению с аналогичным показателем естественной рекурсивной сортировки на 20—25 процентов.

		// 7.6.Дублированные ключи
		// Одна достаточно простая идея заключается в делении файла на три части, одна - для ключей, меньших разделяющего элемента, другая - для ключей, равных ему, и третья - для ключей, больших разделяющего элемента.
		// Ключи, равные разделяющему элементу и встретившиеся в левом подфайле, накапливаются в левом конце файла, ключи, равные разделяющему элементу и встретившиеся в правом подфайле, накапливаются в правом конце файла.
		// непроизводительные расходы системных ресурсов пропорциональны только количеству обнаруженных дублированных ключей.
		// - во-первых, этот метод работает хорошо, даже если в исходном файле вообще нет дублированных ключей, поскольку в этом случае непроизводительные затраты отсутствуют.
		// - Во-вторых, для этого метода характерна линейная зависимость времени выполнения от длины файла при постоянном числе значений ключей :
		// каждая фаза разделения ис ключает из процесса сортировки все ключи со значениями, равными значению разделяющего элемента, так что каждый ключ может быть использован максимум при постоянном числе разделений.
		
		// 7.7 Строки и векторы 
		// Когда сортировочными ключами служат строки, мы можем пользоваться реализацией типов данных, подобных программе 6.11, совместно с реализациями быстрой сортировки, рассматриваемыми в настоящей главе.
		// Проблема заключается в стоимости функции strcmp, которая сравнивает две строки в направлении слева направо, сопоставляя строки символ за символом, затрачивая на это время, пропорциональное количеству символов, совпадающих в началеобоих строк.
		// На заключительных стадиях процесса разделения быстрой сортировки, когда ключи близки друг к другу по значению, почти вся стоимость алгоритмов сосредоточена в его завершающих стадиях, так что исследование с целью совершенствования алгоритма вполне оправдано.
		// На каждой стадии процесса разделения проверяется только один символ (скажем, символ в позиции d), предполагая; что ключи, занимающие позиции от 0 до d - 1 и подлежащие сортировке, совпадают.
		// Мы выполняем разделение на три части, помещая те ключи, d - й символ которых меньше d - ro символа разделяющего элемента, слева,
		// те ключи, d - й символ которых равен d - му символу разделяющего элемента, в середине, а те ключи, d - й символ которых больше d - ro символа разделяющего элемента, справа.
		// Далее мы выполняем обычные действия за исключением того, что мы сортируем средний подфайл, начиная с d + 1 - го символа.
		
		// 7.8. Выборка
		// Одно из важных приложений, имеющее отношение к сортировке, но не требующее сортировки в полном объеме, является операция нахождения медианы из некоторого множества данных.
		// Операция нахождения медианы представляет собой частный случай операции выборки(selection):
		// нахождения k - то наименьшего числа в заданном наборе чисел.
		// Поскольку сам алгоритм не может дать гарантии, что конкретный элемент — суть k-й наименьший, если не проверит и не распознает k-1 элементов, которые меньше к, и N-k элементов, которые больше k, большая часть алгоритмов может возвратить все k наименьших элементов исходного файла без каких-либо дополнительных вычислений.
		// Широко практикуется использование медианы и других показателей порядковой статистики(order statistics) для деления файла на меньшие части.
		// Метод выборки, время выполнения которого в среднем линейно для всех значений к, следует непосредственно из процедуры разделения, используемой в быстрой сортировке.
		// Лемма 7.4. Время выполнения выборки, для которой используется быстрая сортировка, в среднем подчиняется линейной зависимости.
	}
}

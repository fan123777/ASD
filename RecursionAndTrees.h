#pragma once

namespace nsDataStructures
{
	// Рекурсия и деревья
	namespace nsRecursionAndTrees
	{
		void main();

		// Программа 5.1 Функция вычисления факториала(рекурсивная реализация)
		int factorial1(int N);
		int factorial2(int N);

		// Программа 5.2 Сомнительная рекурсивная программа
		int puzzle(int N);

		// Программа 5.3 Алгоритм Эвклида
		int gcd(int m, int n);

		// Программа 5.4 Рекурсивная программа для оценки префиксных выражений
		int eval();

		// Программа 5.6 Применение алгоритма "разделяй и властвуй" для отыскания максимума
		template<typename Item>
		Item max(Item a[], int l, int r)
		{
			if (l == r)
				return a[l];
			int m = (l + r) / 2;
			Item u = max(a, l, m);
			Item v = max(a, m + 1, r);
			If(u > v) return u;
			else return v;
		}

		// Программа 5.7 Решение задачи о ханойских башнях
		void hanoi(int N, int d);

		// Программа 5.8 Применение алгоритма "разделяй и властвуй" для рисования линейки
		void rule(int l, int r, int h);

		// Программа 5.9 Не рекурсивная программа для рисования линейки
		void rule1(int l, int r, int h);

		// Программа 5.10 Числа фибоначчи(рекурсивная реализация)
		int F(int i);

		// Программа 5.11 Числа Фибоначчи(динамическое программирование)
		int F1(int i);

		// Программа 5.12 Задача о ранце(рекурсивная реализация)
		typedef struct { int size; int val; } MyItem;
		int knap(int cap, MyItem a[], int N);

		// Программа 5.13 Задача о ранце(динамическое программирование)
		int knap1(int cap, MyItem a[], int N);



		// В языках программирования рекурсивной программой называют программу, которая обращается к самой себе(подобно тому, как в математике рекурсивной функцией называют функцию, которая определена через понятия самой этой функции).
		// Следовательно, вторая важная особенность рекурсивной программы — наличие условия завершения, позволяющего программе прекратить вызывать себя.
		
		// 5.1 Рекурсивные алгоритмы
		// Рекурсивный алгоритм — это алгоритм, решающий задачу путем решения одного или нескольких более узких вариантов той же задачи.
		// Желательно использовать рекурсивные программы, которые всегда вызывают себя с меньшими значениями аргументов.
		// базовые особенности рекурсивной программы : она вызывает саму себя(с меньшими значениями аргументов) и содержит условие завершения, при выполнении которого непосредственно вычисляет свое результирующее значение.
		// Дабы убедиться в правильности работы программы, можно применить метод математической индукции:
		// - Программа вычисляет 0! (исходное значение)
		// - Если допустить, что программа вычисляет k! для k < N(индуктивное предположение), то она вычисляет и N!.
		// В частности, если следовать правилам математической индукции, необходимо удостовериться, что создаваемые рекурсивные функции удовлетворяют двум основным условиям :
		// - Они должны явно решать задачу для исходного значения.
		// - В каждом рекурсивном вызове должны использоваться меньшие значения аргументов.
		// Программа 5.3 — компактная реализация алгоритма Евклида для отыскания наибольшего общего делителя для двух целых чисел.
		// Число t делит и х и у тогда, и только тогда, когда оно делит и у и х mod у(х по модулю у), поскольку x равно х mod у плюс число, кратное у.
		// В принципе, любой цикл for можно заменить эквивалентной рекурсивной программой.
		
		// 5.2 Разделяй и властвуй
		// Во множестве рассматриваемых в книге программ используется два рекурсивных вызова, каждый из которых работает приблизительно с половиной входных данных.
		// Эта рекурсивная схема - вероятно, наиболее важный случай хорошо известного метода "разделяй и властвуй" разработки алгоритмов, который служит основой для важнейших алгоритмов.
		// Как обычно, сам код предполагает проверку правильности вычисления методом индукции :
		// - Он явно и немедленно отыскивает максимальный элемент массива, размер которого равен 1.
		// - Для N > 1 код разделяет массив на два, размер каждого из которых меньше N, исходя из индуктивного предложения, находит максимальные элементы в обеих частях и возвращает большее из этих двух значений, которое должно быть максимальным значением для всего массива.
		// Лемма 5.1 Рекурсивная функция, которая разделяет задачу размерности N на две независимые(непустые) решающие ее части, рекурсивно вызывает себя менее N раз.
		// Лемма 5.2 Рекурсивный алгоритм "разделяй и властвуй" решения задачи о ханойских башнях дает решение, приводящее к 2N — 1 перемещениям.
		// Рекурсивно определенные геометрические узоры иногда называют фракталами.
		
		// 5.3 Динамическое программирование
		// Рекуррентное соотношение — это рекурсивная функция с целочисленными значениями.
		// Рассуждения, приведенные в предыдущем абзаце, подсказывают, что любую такую функцию можно приближенно вычислить, вычисляя все значения функции, начиная с наименьшего, используя на каждом шаге ранее вычисленные значения для подсчета текущего значения.
		// Эта технология называется восходящим динамическим программированием (battom-up dynamic programming).
		// Нисходящее динамическое программирование (top-down dynamic programming) — еще более простая технология, которая позволяет автоматически выполнять рекурсивные функции при том же(или меньшем) количестве итераций, что и восходящее динамическое программирование.
		// Иногда нисходящее динамическое программирование называют также мемуаризацией(memoization).
		// Задача о ранце:
		// вор, грабящий сейф, находит в нем N видов предметов различных размеров и ценности, но имеет только небольшой ранец емкостью М, в котором может унести награбленное.
		// Для ранца размера cap, для каждого доступного типа элемента i определяется общая стоимость элементов, которые можно было бы унести, укладывая i - ый элемент в ранец при оптимальной упаковке остальных элементов.
		// Этот оптимальный способ упаковки - просто способ упаковки, определенный(или который будет определен) для меньшего ранца размера cap - items[i].size.
		// оптимальные принятые решения в дальнейшем не требуют пересмотра.
		// Как только установлено, как оптимально упаковать ранцы меньших размеров, эти задачи не требуют повторного исследования независимо от следующих элементов.
		// Динамическое программирование принципиально исключает все повторные вычисления в любой рекурсивной программе, при условии, что мы можем себе позволить сохранять значения функции для аргументов, которые меньше чем интересующий вызов.
		// Лемма 5.3 Динамическое программирование уменьшает время выполнения рекурсивной функции до максимального значения, которое потребуется на вычисление функции для всех аргументов, которые меньше или равны данному аргументу, при условии, что стоимость рекурсивного вызова остается постоянной.
		// При использовании нисходящего динамического программирования известные значения сохраняются; при использовании восходящего динамического программирования они вычисляются заранее.В общем случае нисходящее динамическое программирование предпочтительней восходящего, поскольку:
		// - оно представляет собой механическую трансформацию естественного решения задачи;
		// - порядок решения подзадач определяется сам собой;
		// - решение всех подзадач может не потребоваться.

		// 5.4 Деревья
		// Деревья — это математические абстракции, играющие главную роль при разработке и анализе алгоритмов, поскольку:
		// - мы испольем деревья для описания динамических свойств алгоритмов;
		// - мы строим и используем явные структуры данных, которые являются конкретными реализациями деревьев.
		// Мы неформально рассмотрим различные типы деревьев, которые следует рассматривать в порядке сужения самого этого понятия:
		// - Деревья
		// - Деревья с корнем
		// - Упорядоченные деревья
		// - М-арные и бинарные деревья
		// Дерево (tree) — это непустая коллекция вершин и ребер, удовлетворяющих определенным требованиям.
		// Вершина(vertex) — это простой объект(называемый также узлом(node)), который может иметь имя и содержать другую связанную с ним информацию; ребро(edge) — это связь между двумя вершинами.
		// Путь(path) в дереве — это список отдельных вершин, в котором следующие друг за другом вершины соединяются ребрами дерева.
		// Определяющее свойство дерева — существование только одного пути, соединяющего любые два узла.
		// Если между какой - либо парой узлов существует более одного пути или если между какой - либо парой узлов путь отсутствует, мы имеем граф, а не дерево.
		// Несвязанный набор деревьев называется бором(forest).
		// Дерево с корнем (единственным, rooted) — это дерево, в котором один узел назначен корнем(root) дерева.
		// В области компьютеров термин дерево обычно применяется к деревьям с корнем, а термин свободное дерево(free tree) — к более общим структурам.
		// В дереве с корнем любой узел является корнем поддерева, состоящего из него и расположенных под ним узлов.
		// Каждый узел (за исключением корня) имеет только один узел над ним, который называется его родительским узлом(parent);
		// узлы, расположенные непосредственно под данным узлом, называются его дочерними узлами (children).
		// Узлы, не имеющие дочерних узлов, называются листьями (leaves) или терминальными(оконечными, terminal) узлами.
		// Для соответствия с последним применением узлы, имеющие хотя бы один дочерний узел, иногда называются нетерминальными (nonterminal) узлами.
		// Упорядоченное (ordered) дерево — это дерево с корнем, в котором определен порядок следования дочерних узлов каждого узла.
		// Если каждый узел должен иметь конкретное количество дочерних узлов, появляющихся в конкретном порядке, мы имеем М-арное дерево.
		// Бинарное дерево (binary tree) — это упорядоченное дерево, состоящее из узлов двух типов : внешних узлов без дочерних узлов и внутренних узлов, каждый из которых имеет ровно два дочерних узла.
		// Поскольку два дочерних узла каждого внутреннего узла упорядочены, говорят о левом дочернем узле(left child) и правом дочернем узле(right child) внутренних узлов.
		// Каждый внутренний узел должен иметь и левый, и правый дочерние узлы, хотя один из них или оба могут быть внешними узлами.
		// Лист в M-арном дереве - это внутренний узел, все дочерние узлы которого являются внешними.
		// Далее рассматриваются формальные определения, представления и приложения, в порядке расширения понятий:
		// - бинарные и М-арные деревья
		// - упорядоченные деревья
		// - деревья с корнем
		// - свободные деревья
		// Определение 5.1 Бинарное дерево — это либо внешний узел, либо внутренний узел, связанный с парой бинарных деревьев, которые называются левым и правым поддеревьями этого узла.
		// Так, например, мы реализуем абстрактную операцию перехода к левому поддереву с помощью ссылки на указатель типа х = х->1.
		// Как и в случае со связными списками, в определенных ситуациях узлы дерева хранятся в массиве, а в качестве связей используются индексы, а не указатели.
		// Из-за наличия такого множества различных возможных представлений можно было бы разработать ADT(Abstract Data Type) (абстрактный тип данных) бинарного дерева, инкапсулирующий важные операции, которые нужно выполнять, и разделяющий использование и реализацию этих операций.
		// данный подход не используется, поскольку
		// - чаще всего мы используем представление с двумя связями;
		// - мы используем деревья для реализации ADT более высокого уровня, и хотим сосредоточить внимание на этой теме;
		// - мы работаем с алгоритмами, эффективность которых зависит от конкретного представления, — это обстоятельство может быть упущено в ADT.
		// Существуют три естественных операции, для которых подобное осложнение не возникает: вставка нового узла в нижней части дерева(замена нулевой связи связью с новым узлом), удаление листа(замена связи с ним нулевой связью) и объединение двух деревьев посредством создания нового корня, левая связь которого указывает на одно дерево, а правая - на другое.
		// Опредление 5.2 М-арное дерево - это внешний узел, либо внутренний узел, связанный с упорядоченной последовательностью М деревьев, которые также являются М-арными деревьями.
		// Определение 5.3 Дерево (также называемое упорядоченным деревом) — это узел (называемый корнем), связанный с последовательностью несвязанных деревьев.
		// Такая последовательность называется бором.
		// Лемма 5.4 Существует однозначное соответствие между бинарными деревьями и упорядоченными борами.
		// Определение 5.4 Дерево с корнем (или неупорядоченное дерево) — это узел (называемый корнем), связанный с множественным набором деревьев с корнем.
		// (Такой множественный набор называется неупорядоченным бором.)
		// Для правильного определения деревьев без корня, неупорядоченных деревьев и свободных деревьев потребуется начать с определения графов(graphs).
		// Определение 5.5 Граф — это набор узлов с набором ребер, которые соединяют пары отдельных узлов(причем любую пару узлов соединяет только одно ребро).
		// Последовательность ребер, ведущих от одного узла до другого, когда ни один узел не посещается дважды, называется простым путем.
		// Граф является связным (connected), если существует простой путь, связывающий любую пару узлов.Простой путь, у которого первый и последний узел совпадают, называется циклом(cycle).
		// Каждое дерево является графом; а какие же графы являются деревьями? Граф считается деревом, если он удовлетворяет любому из следующих четырех условий :
		// - Граф имеет N — 1 ребер и ни одного цикла.
		// - Граф имеет N— 1 ребер и является связным. 
		// - Только один простой путь соединяет каждую пару вершин в графе.
		// - Граф является связным, но перестает быть таковым при удалении любого ребра.
		
		// 5.5 Математические свойства бинарных деревьев
		// ...226
	}
}

#pragma once

#include "PriorityQueue.h"

namespace nsSorting
{
	namespace ArrayPQ = nsPriorityQueue::nsArrayPQ;

	// Очереди по приоритетам и пирамидальная сортировка
	namespace nsPriorityQueueAndHeapSort
	{
		void main();

		// Часто мы накапливаем некоторый набор записей, после чего обрабатываем запись с максимальным значением ключа, затем, возможно, накопление записей продолжается, потом обрабатывается запись с наибольшим текущим ключом и т.д.
		// Соответствующая структура данных в подобного рода средах поддерживает операции вставки нового элемента и удаления наибольшего элемента.
		// Такая структура данных называется очередью по приоритетам.
		// Определение 9.1. Очередь по приоритетам представляет собой структуру элементов с ключами, которая поддерживает две основные операции : вставку нового элемента и удаление элемента с наибольшим значением ключа.
		// Необходимо построить и поддерживать структуры данных, содержащие записи с числовыми ключами(приоритетами), которые поддерживают некоторые из следующих операций:
		// - Создать (construct) очередь по приоритетам из N заданных элементов
		// - Вставить (insert) новый элемент
		// - Удалить наибольший (remove the maximum) элемент
		// - Изменить приоритет (change the priority) произвольно выбранного элемента
		// - Удалить (remove) произвольно выбранный элемент
		// - Объединить (join) две очереди но приоритетам в одну
		// Как и в случае других структур данных, в этот набор потребуется добавить стандартные операции создать, проверить наличие элементов и, возможно, операции уничтожить и копировать.
		// Например, у некоторых клиентских программ часто возникает необходимость найти наибольший(find the maximum) элемент в очереди по приоритетам без его удаления из очереди.
		// Или же понадобится операция заменить наибольший (replace the maximum) элемент новым элементом.
		// Мы можем реализовать подобного рода операции за счет использования в качестве строительных блоков две базовых операции:
		// - операцию найти наибольший можно представить через операцию удалить наибольший и следующую за ней операцию вставить
		// - а операцию заменить наибольший можно представить либо через операцию вставить и следующую за ней удалить наибольший, либо через операцию удалить наибольший и следующую за ней вставить.
		// для очередей по приоритетам наиболее характерными являются операции удалить наибольший(remove - the - maximum) и вставить(insert), поэтому им и будет уделяться основное внимание.
		// Мы почти приблизимся к идеалу в смысле возможности выполнить операцию удалить наибольший за время, которое находится в логарифмической зависимости от числа элементов в очереди, а все остальные операции - за постоянное время.
		// в разделах 9.2—9.4 внимание сосредоточивается на рассмотрении классической структуры данных, получившей название сортирующее дерево(heap), которая обеспечивает эффективную реализацию всех операций, кроме операции объединить.
		// в разделе 9.7 рассматриваются более сложные структуры данных, получившие название биномиальных очередей(binomial queue), которые используются для реализации всех операций(в том числе и операции объединить) в наихудшем случае логарифмической зависимости времени выполнения.

		// 9.1. Элементарные реализации
		// Программа 9.2 демонстрирует реализацию, которая в качестве базовой структуры данных использует неупорядоченный массив.
		// Операция найти наибольший элемент реализуется следующей последовательностью действий : сначала производится просмотр массива с целью обнаружения наибольшего элемента, затем осуществляется замена наибольшего элемента на последний элемент с последующим уменьшением размера очереди на единицу.
		// Выбор в пользу того, оставить элементы неотсортированными или разместить их в определенном порядке, определяется тем, что упорядоченная совокупность элементов позволяет выполнить операции удалить наибольший или найти наибольший за постоянное время, но это также означает необходимость прохода по всему списку, чтобы выполнить операцию вставить.
		// Неупорядоченная последовательность элементов позволяет выполнить операцию вставить за постоянное время, а для операции удалить наибольший или найти наибольший потребуется просмотреть весь список.
		// Неупорядоченность представляет собой прототипный "ленивый" подход к решению проблемы, в рамках которого выполнение работы откладывается до тех пор, пока это не станет необходимым(в данном случае, поиск наибольшего элемента);
		// упорядоченная последовательность представляет собой прототипный "энергичный" подход к решению проблемы, когда заранее выполняется максимально возможный объем работы(поддержка списка отсортированным на случай выполнения операции вставка), дабы обеспечить максимальную эффективность последующих операций.
		// Реализация, работающая с неупорядоченными списками, может оказаться приемлемой в приложениях, в которых выполняются лишь немногие операции удалить наибольший и в то же время очень большое количество вставок, тогда как упорядоченный список лучше подходит в тех случаях, когда выполняется большое число операций найти наибольший либо когда вставляемые элементы преимущественно больше уже находящихся в очереди по приоритетам.

		// 9.2. Пирамидальная структура данных 
		// Основной темой настоящей главы является простая структура данных, получившая название сортирующего дерева(heap), которая может эффективно поддерживать основные операции в очереди по приоритетам.
		// В сортирующем дереве записи хранятся в виде массива таким образом, что каждый ключ обязательно принимает значение большее, чем значения двух других ключей, занимающих относительно него строго определенные положения.
		// Определение 9.2. Дерево называется пирамидально упорядоченным(heap - ordered), если ключ в каждом его узле больше или равен ключам всех потомков этого узла(если таковые имеются).
		// Эквивалентная формулировка : ключ в каждом узле пирамидально упорядоченного дерева меньше или равен ключу узла, который является родителем данного узла.
		// Лемма 9.1. Ни один из узлов пирамидально упорядоченного дерева не может иметь ключа, большего чем ключ корня дерева.
		// Однако особенно удобно пользоваться полным бинарным деревом(complete binary tree).
		// Определение 9.3. Сортирующее дерево есть совокупность узлов с ключами, образующих полное пирамидально упорядоченное бинарное дерево, представленное в виде массива.
		// Родителя узла, находящегося в позиции i, необходимо искать в позиции |_i/2_| и, соответственно, два потомка узла в позиции / находятся в позициях 2i и 2i + 1.
		
		// 9.3. Алгоритмы для сортирующих деревьев 
		// Все алгоритмы очередей по приоритетам для сортирующих деревьев работают таким образом, что сначала вносят простое изменение, способное нарушить структуру пирамиды, затем выполняют проход вдоль пирамиды, внося при этом в сортирующее дерево такие изменения, которые гарантируют, что структура сортирующего дерева сохраняется везде.
		// Этот процесс иногда называют установлением пирамидального порядка(heapifying).
		// Если свойства сортирующего дерева нарушены из-за того, что ключ некоторого узла становится больше ключа родительского узла, можно сделать шаг в направлении исправления этого нарушения, обменяв местами этот узел с его родителем.
		// Нисходящая установка структуры сортирующего дерева:
		// Обратите внимание на то обстоятельство, что если N есть четное число и к равно N / 2, то узел в позиции к имеет только одного потомка — этот случай требует особого подхода!
		// ...368
	}
}

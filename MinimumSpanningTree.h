#pragma once

namespace nsAlgorithmsOnGraphs
{
	// Минимальные остовные деревья
	namespace nsMinimumSpanningTree
	{
		void main();
		void test();

		// Модели графов, в которых мы связываем веса (weights) или стоимости(costs) с каждым ребром, используются во многих приложениях.
		// Естественно, в таких ситуациях возникают вопросы, касающиеся различных аспектов минимизации стоимости.
		// Мы будем изучать алгоритмы решения двух задач такого рода:
		// - определение пути с наименьшей стоимостью, соединяющего все точки
		// - отыскание пути наименьшей стоимости, соединяющего две заданных точки.
		// Первый тип алгоритма применяется для решения задач на неориентированных графах, которые представляют такие объекты как электрические цепи, находит минимальное остовное дерево(minimum spanning tree);
		// Второй тип алгоритма, применяемый для решения задач на орграфах, которые представляют такие объекты, как карты авиарейсов, определяет кратчайшие пути(shortest path), и они являются темой обсуждений в главе 21.
		// В этом разделе мы будем изучать три классических алгоритма, которые легко понять на концептуальном уровне;
		// Определение 20.1. Дерево MST (minimal spanning tree - минимальное остовное дерево) взвешенного графа есть остовное дерево, вес которого(сумма весов его ребер) не превосходит вес любого другого остовного дерева.
		// Если все веса положительны, достаточно определить дерево MST как множество ребер с минимальным общим весом, которые соединяют все вершины, ибо такое множество и должно образовать остовное дерево.
		// Если ребра могут иметь равные веса, минимальное остовное дерево может не быть единственным.
		// В данной главе мы будем работать исключительно с неориентированными графами.
		
		// 20.1. Представления 
		// Дерево MST графа G есть подграф графа G, который сам по себе является деревом, в связи с чем появляется множество вариантов, основными из которых являются:
		// - Граф.
		// - Связный список ребер.
		// - Вектор указателей на ребра.
		// - Вектор, индексированный именами вершин с родительскими связями.
		
		// 20.2. Принципы, положенные в основу алгоритмов построения дерева MST
		// Первое из этих свойств, на которое мы далее будем ссылаться как на свойство сечения, относится к идентификации ребер, которые должны входить в дерево MST заданного графа.
		// Определение 20.2. Сечение (cut) графа есть разделение множества всех вершин графа на два непересекающихся множества.
		// Пересекающее ребро(crossing edge) есть ребро, которое соединяет вершину одного множества с вершиной другого множества.
		// Свойство 20.1. (Свойство сечения). При любом сечении графа каждое минимальное пересекающее ребро принадлежит некоторому дереву MST и каждое дерево MST содержит минимальное пересекающее ребро.
		// Если все веса ребер графа различны, он обладает единственным деревом MST;
		// В частности, из выполнения условия оптимальности следует, что каждое ребро дерева MST есть минимальное ребро, пересекающее сечение, определенный вершинами двух поддеревьев, соединенных этим ребром.
		// Второе свойство, которое мы будем называть свойством цикличности, применяется с целью выявления ребер, которые не должны входить в дерево MST графа.
		// Свойство 20.2. (Свойство цикличности). Пусть задан граф G, рассмотрим граф G' который получается в результате добавления к графу G ребра е.
		// Добавление ребра е в дерево MST графа G и удаление максимального ребра из полученного в результате этой операции цикла дает дерево MST графа G'.
		// Первый подход к поиску дерева MST, который мы намерены исследовать во всех подробностях, заключается в постепенном построении MST, добавляя одно ребро за раз:
		// мы начинаем построение с произвольной вершины и рассматриваем ее как дерево MST, состоящее из одной вершины, затем добавляем к нему V- 1 вершин, при этом каждый раз выбираем минимальное ребро, которое соединяет вершину, уже включенную в дерево MST, с вершиной, которая еще не содержится в MST.
		// Этот метод известен как алгоритм Прима(Prim's algorithm).
		// Свойство 20.3. Алгоритм Прима вычисляет дерево MST любого связного графа.
		// Еще один подход к вычислению дерева MST предусматривает многократное применение свойства цикличности:
		// мы добавляем ребра по одному за раз во мнимое дерево MST, с удалением максимального ребра из цикла, если таковой был образован.
		// Второй подход отыскания дерева MST, который будет изучаться во всех подробностях, предусматривает обработку ребер в порядке возрастания их длины(первым обрабатывается наиболее короткое) с добавлением в MST каждого ребра, которое не образует цикла с ребрами, включенными в MST раньше;
		// Этот метод известен как алгоритм Крускала (Kruskal's algorithm).
		// Свойство 20.4. Алгоритм Крускала вычисляет дерево MSTлюбого связного графа. 
		// Третий подход к построению дерева MST, который мы сейчас рассмотрим подробно, известен как алгоритм Борувки(Boruvka's algorithm).
		// На первом шаге в дерево MST добавляются ребра, которые соединяют каждую вершину с ее ближайшим соседом.
		// Свойство 20.5. Алгоритм Борувки вычисляет дерево MST для любого связного графа.
		// В частности, мы можем в произвольном порядке применять свойство сечения для выбора того или иного ребра в качестве ребра MST или свойство цикла для обоснования отказа включить ребро в MST и продолжать эту процедуру до тех пор, пока станет невозможным увеличение ни числа принятых, ни числа отвергнутых ребер.
		// Согласно описанию, приведенному в этом разделе и в классической литературе, для выполнения указанных выше алгоритмов должны быть разработаны высокоуровневые абстрактные операции, такие как:
		// - Отыскание минимального ребра, соединяющего два поддерева.
		// - Определение, будет ли образован цикл при включении конкретного ребра.
		// - Удаление самого длинного ребра цикла.
		
		// 20.3. Алгоритм Прима и поиск по приоритету
		// алгоритм Прима является простейшим из всех алгоритмов построения дерева MST, ему отдают предпочтение в случае насыщенных графов.
		// Мы поддерживаем сечение графа, состоящее из древесных вершин (те, которые выбраны для представления дерева MST) и недревесных вершин(те, которые не попадают в дерево MST).
		// Мы начинаем с того, что помещаем произвольную вершину в дерево MST, затем помещаем в MST минимальное пересекающее ребро(которое превращает недревесную вершину дерева MST в древесную) и повторяем подобную операцию V - 1 раз, пока все вершины не окажутся в дереве.
		// Короче говоря, нам не надо проверять расстояние от вершины w до каждой вершины дерева - нам нужно знать минимальное расстояние в каждый момент и проверять, вызывает ли добавление вершины v в дерево необходимость изменить это минимальное расстояние.
		// Для реализации этой идеи нам потребуются такие структуры данных, которые предоставляли бы следующую информацию:
		// - Ребра дерева.
		// - Самое короткое дерево, соединяющее недревесные вершины с деревом.
		// - Длина этого ребра.
		// Простейшей реализацией каждой из этих структур данных будет вектор, индексированный именами вершин(мы можем использовать этот вектор для хранения древесных ребер, индексируя их именами вершин по мере их добавления в дерево).
		// После включения нового ребра (и вершины) в дерево, мы должны выполнить еще две процедуры:
		// - Проверить, приблизит ли добавление нового ребра какую-либо из недревесньх вершин к искомому дереву.
		// - Найти следующее ребро, подлежащее включению в искомое дерево.
		// Свойство 20.6. Используя алгоритм Прима, можно найти дерево MST насыщенного графа за линейное время.
		// Будем называть краевыми вершинами (fringe vertices) подмножестю недревесных вершин, которые соединены посредством ребер из бахромы с вершинами дерева, и будем использовать те же векторы mst, fr и wt, индексированные именами вершин.
		// Свойство 20.7. Использование реализации алгоритма Прима с поиском по приоритету, в котором для реализации очереди с приоритетами применяется полное бинарное дерево, позволяет вычислить дерево MST за время, пропорциональное Е*lgV.
		// Свойство 20.8. Для всех графов и приоритетных функций можно вычислить остовное дерево при помощи поиска по приоритетам за линейное время плюс время, пропорциональное продолжительности выполнения V операций вставок(insert), V операций удалить минимальное ребро(delete the minimum) и Е операций уменьшить ключ(decrease key) в очереди с приоритетами, размер которой не превышает V.

		// 20.4. Алгоритм Крускала
		// Мы начнем построение с вырожденного леса, содержащего V деревьев, состоящих из одной вершины каждое, и выполняем операцию объединения двух деревьев(используя для этой цели по возможности наиболее короткие ребра), пока не останется единственное дерево, а именно, минимальное остовное дерево.
		// Свойство 20.9. Алгоритм Крускала вычисляет дерево MST графа за время, пропорциональное E*lg(E).
		// Свойство 20.10. Версия алгоритма Крускала, в основу которой положена очередь с приоритетами, вычисляет дерево MST графа за время, пропорциональное Е + X*lg(V), где X есть число ребер графа, не превосходящих по длине самое длинное ребро в дереве MST.
		// применимость абстракции поиска-объединения к алгоритму Крускала и применимость абстракции очереди с приоритетами к алгоритму Прима стали для многих исследователей основной мотивацией для поиска более совершенных реализаций упомянутых выше АТД.

		// 20.5. Алгоритм Борувки
		// мы строим дерево MTS, добавляя ребра в развернутый лес поддеревьев MTS, но делаем это поэтапно, добавляя на каждом этапе несколько ребер в дерево MTS.
		// На каждом этапе мы отыскиваем наиболее короткое ребро, которое соединяет каждое поддерево MTS с некоторым другим поддеревом, затем включаем каждое такое ребро в дерево MTS.
		// Прежде всего, мы построим вектор, индексированный именами вершин, который для каждого поддерева MTS определяет ближайшего соседа.
		// Затем на каждом ребре графа мы выполняем следующие операции:
		// - Если соединяются две вершины одного и того же дерева, результат операции отбрасывается.
		// - В противном случае выполните проверку расстояний между вершинами двух ближайших соседних деревьев, которые соединяет это ребро, и обновите их, если в этом есть необходимость.
		// Следующие три главных фактора делают эту реализацию эффективной:
		// - Стоимость каждой операции find фактически остается постоянной.
		// - Каждый этап уменьшает число поддеревьев MTS в лесе, по меньшей мере, в два раза.
		// - На каждом этапе отбрасывается значительное количество ребер.
		// Свойство 20.11. Время прогона алгоритма Борувки с целью вычисления дерева MTS заданного графа есть О(Е*lg(V)lg*(Е)).

		// 20.6. Сравнения и усовершенствования
		// ...270
	}
}

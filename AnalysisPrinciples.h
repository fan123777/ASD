#pragma once

// Принципы анализа алгоритмов
namespace nsAnalysisPrinciples
{
	void main();

	// - Проиллюстрировать процесс.
	// - Описать в одном месте используемые математические соглашения.
	// - Обеспечить основу для обсуждения вопросов высокого уровня.
	// - Выработать понимание научной основы выводов, которые делаются при анализе алгоритмов.

	// 2.1. Разработка и эмпирический анализ
	// Один из первых шагов для продвижения вперед в понимании производительности алгоритмов — это эмпирический анализ.
	// Первая проблема, возникающая перед нами в эмпирическом анализе — это разработка корректной и полной реализации.
	// Вторая проблема, с которой мы сталкиваемся при эмпирическом анализе, — это определение природы входных данных и других факторов, оказывающих прямое влияние на производимые эксперименты.
	// Обычно существуют три основных возможности: реальные данные, случайные данные и ошибочные данные.
	// Один из подходов заключается в построении алгоритмов за счет внесения небольших изменений в алгоритмы, существующие для данной задачи, поэтому сравнительное изучение просто необходимо.

	// 2.2 Анализ алгоритмов 
	// Среди причин, по которым выполняется математический анализ алгоритмов, находятся следующие:
	// - Для сравнения разных алгоритмов, предназначенных для решения одной задачи
	// - Для приблизительной оценки производительности программы в новой среде
	// - Для установки значений параметров алгоритма
	// Один из способов определения важных величин заключается в использовании механизма профилирования(механизма, доступного во многих реализациях C++, который включает в себя счетчик количества выполнений каждой инструкции) для нахождения наиболее часто исполняемых частей программы по результатам нескольких пробных запусков.
	// Средней может быть математическая функция, не зависящая от данных, для которых используется программа, а наихудшей — странная конструкция, которая ни когда не встречается на практике, но в большинстве случаев эти виды анализа пре доставляют полезную информацию о производительности.

	// 2.3 Рост функций 
	// Большинство алгоритмов имеют главный параметр N, который значительно влияет на время их выполнения.
	// Алгоритмы в этой книге обычно имеют время выполнения, пропорциональное одной из следующих функций:
	// 1 - Большинство инструкций большинства программ запускается один или несколько раз.Если все инструкции программы обладают таким свойством, мы говорим, что время выполнения программы постоянно.
	// log(N) - Когда время выполнения программы является логарифмическим, программа становится медленнее с ростом N.
	// N - Когда время выполнения программы является линейным, это обычно значит, что каждый входной элемент подвергается небольшой обработке.
	// N*log(N) - Время выполнения, пропорциональное NlogN, возникает тогда, когда алгоритм решает задачу, разбивая ее на меньшие подзадачи, решая их независимо и затем объединяя решения.
	// N*N - Когда время выполнения алгоритма является квадратичным, он полезен для практического использования для относительно небольших задач.
	// N*N*N - Похожий алгоритм, который обрабатывает тройки элементов данных(возможно, в цикле тройного уровня вложенности), имеет кубическое время выполнения и практически применим лишь для малых задач.
	// 2^N - Лишь несколько алгоритмов с экспоненциальным временем выполнения имеет практическое применение, хотя такие алгоритмы возникают естественным образом при попытках прямого решения задачи.
	// Наименьшее целое число, большее lg(N), равно количеству бит, необходимых для представления N в двоичном формате;
	// точно так же наименьшее целое, большее log10(N) - это количество цифр, необходимое для представления N в десятичном формате.
	// При анализе алгоритмов часто возникает дискретизованная версия функции натурального логарифма, называемая гармоническими числами. N-тое гармоническое число определяется выражением
	// Hn = 1 + 1/2 + 1/3 + ... + 1/N
	// Hn = lnN + y + 1/(12*N)
	// у = 0.57721 - постоянная Эйлера
	// Последовательность чисел О 1 1 2 3 5 8 13 21 34 55 89 144 233 377 ... определенная формулой 
	// Fn = Fn-1 + Fn-2, где N=>2, F0 = 0, F1 = 1 известна, как числа Фибоначчи.
	// отношение двух последовательных чисел приближенно равно золотому сечению(golden ratio) f = (1 +sqr(5)) / 2 = 1.61803.
	// При анализе алгоритмов часто встречается также функция факториал N!
	// Она также возникает при анализе алгоритмов, поскольку представляет собой количество способов упорядочения N объектов.

	// 2.4 О-нотация
	// Математическая запись, позволяющая отбрасывать подробности при анализе алгоритмов, называется О - нотацией.Она определена следующим образом.
	// Определение 2.1 Говорят, что функция g(N) является O(f(N)), если существуют такие постоянные с0 и No, что g(N) < c0f(N) для всех N > No.
	// О-нотация используется по трем основным причинам:
	// - Чтобы ограничить ошибку, возникающую при отбрасывании малых слагаемых в математических формулах.
	// - Чтобы ограничить ошибку, возникающую тогда, когда не учитываются те части программы, которые дают малый вклад в анализируемую сумму.
	// - Чтобы классифицировать алгоритмы согласно верхней границе их общего времени выполнения.
	// Формула с одним О-слагаемым называется асимптотическим выражением(asymptotic expression).

	// 2.5 Простейшие рекурсии
	// ...60
}

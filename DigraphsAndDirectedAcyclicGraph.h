#pragma once

namespace nsAlgorithmsOnGraphs
{
	// Орграфы и ориентированные ациклические графы 
	namespace nsDigraphsAndDirectedAcyclicGraph
	{
		void main();
		void test();

		// Если мы придаем значение, в каком порядке описываются две вершины каждого ребра графа, мы получаем совершенно другой комбинаторный объект, известный как ориентированный граф(directed graph), или орграф(digraph).
		// В орграфах обозначение s-t описывает ребро, которое ведет из вершины s в вершину t, но при этом оно не дает никакой информации о том, существует ли ребро, ведущее из t в s.
		// Имеется четыре вида отношений, в которых могут находиться две любые вершины орграфа:
		// связывающее их ребро отсутствует, ребро s - t, ведущее из s в t, ребро t - s, ведущее из t в s, и два ребра s - t и t - s, которые указывают на наличие связи в обоих направлениях.
		// работа с орграфами существенно отличается от работы с неориентированными графами.
		// В этом заключается суть проблемы, известной как задача составления расписаний (scheduling problem).
		// Она не имеет смысла, если в орграфе имеется цикл, в подобного рода ситуациях мы работаем с графами DAG(directed acyclic graph — ориентированный ациклический граф).
		
		// 19.1. Глоссарий и правила игры 
		// Определение 19.1. Ориентированный граф (или орграф) представляет собой некоторый набор вершин плюс некоторый набор ориентированных ребер, которые соединяют упорядоченные пары вершин(при этом дублированные ребра отсутствуют).
		// Мы говорим, что ребро направлено из первой вершины во вторую вершину.
		// Определение 19.2. Ориентированный путь (directed path) в орграфе есть список вершин, в котором имеется(ориентированное) ребро орграфа, соединяющее каждую вершину списка со следующим элементом этого списка.
		// Мы говорим, что вершина t достижима (reachable) из вершины s, если существует ориентированный путь из s в t.
		// Мы принимаем соглашение, согласно которому каждая вершина достижима сама из себя, и обычно реализуем это свойство за счет того, что в представление нашего орграфа включаем петли.
		// Что более важно, для орфафов и графов характерны существенные структурные различия.
		// Например, тот факт, что вершина t достижима из вершины s в орграфе, ничего не говорит о том, достижима ли s из t.
		// Полустепень захода (indegree) вершины орграфа есть число ориентированных ребер, которые ведут в эту вершину.
		// Полустепень исхода (outdegree) вершины орграфа есть число ориентированных ребер, которые исходят из этой вершины.
		// Ни одна из вершин орграфа не достижима из вершины с полустепенью исхода 0, эта вершина получила название сток(sink);
		// вершина с полустепенью захода 0 получила название исток(source), она не достижима ни из одной другой вершины орграфа.
		// Орграфы, в которых допускается существование петель и в которых каждая вершина обладает полустепенью исхода, равной 1, называется картой(mар) (отображение самого на себя множества целых чисел в диапазоне от 0 до V - 1).
		// Обращение (reverse) орграфа - это орграф, который мы получаем, поменяв ориентацию всех ребер орграфа на обратную.
		// Обратите внимание на тот факт, что путь s-t-s есть цикл длиной 2 в орграфе, в то время как цикл в неориентированном графе должен проходить через три различных вершины.
		// Определение 19.3. Ориентированный ациклический граф (directed acyclic graph), или граф DAG, — это орграф, не содержащий направленных циклов.
		// Неориентированный граф связен, если существует путь из каждой его вершины в любую другую вершину;
		// что касается орграфов, то мы модифицируем данное выше определение следующим образом:
		// Определение 19.4. Орграф называется сильно связным(strongly connected), если каждая его вершина достижима из любой другой вершины.
		// Мы говорим, что пара вершин s и t любого графа сильно связана (strongly connected) или что эти вершины являются взаимно достижимыми(mutually reachable), если существует ориентированный путь из s в t и ориентированный путь из t в s.
		// По-другому о том факте, что пара вершин сильно связана, можно сказать следующим образом:
		// они лежат на некотором ориентированном циклическом пути.
		// Обратите внимание на тот факт, что ни один граф DAG, содержащий более одной вершины, не может быть сильно связным.
		// Как и простая связность в неориентированных графах, это отношение транзитивно: 
		// если s сильно связана с t, a t сильно связана с u, то s сильно связана с u.
		// Свойство 19.1. Орграф, не принадлежащий к классу сильно связных графов, содержит некоторый набор сильно связных компонент(strongly connected components) (или, для краткости, strong components — сильных компонент), которые представляют собой максимальные сильно связные подграфы, и некоторый набор ориентированных ребер, идущих от одной компоненты к другой.
		// Свойство 19.2. Пусть задан орграф D, определим еще один орграф K(D), в котором одна вершина соответствует каждой сильной компоненте орграфа D, и одно ребро K(D) соответствует каждому ребру орграфа D, которое соединяет вершины различных сильных компонент(соединяет вершины в К, соответствующие сильным компонентам, которые он соединяет в D).
		// Тогда K(D) будет граф DAG(который мы будем называть базовым графом DAG(kernel DAG), или ядром DAG, графа D).
		// Мы должны исследовать, по меньшей мере, три следующих ситуации:
		// - Связность.
		// Мы зарезервируем термин связный (connected) для неориентированных графов.
		// В случае орграфов мы можем утверждать, что две вершины связаны, если они связаны в неориентированном графе, получаемом, когда направления ребер игнорируются, тем не менее, мы будем избегать подобной трактовки.
		// - Достижимость.
		// Мы говорим, что вершина t орграфа достижима из вершины s, если существует ориентированный путь из s в t.
		// - Сильная связность. 
		// Мы хотим обеспечить поддержку операции АТД орграфа, которые принимают в качестве аргументов две вершины s и t и позволяют нам проверить:
		// - достижима ли t из s; 
		// - существует ли сильная связность вершин s и t (взаимная достижимость). 
		
		// 19.2. Анатомия поиска DFS в орграфах 
		// Основной принцип этого рекурсивного алгоритма можно сформулировать следующим образом:
		// чтобы посетить каждую вершину, достижимую из данной вершины, мы помечаем эту вершину как посещенную, затем(рекурсивно) посещаем все вершины, в которые можно пройти из каждой вершины, внесенные в список смежных с ней вершин.
		// Термин стандартный поиск в глубину на списках смежных вершин(standard adjacency-lists DFS) будет обозначать процесс вставки последовательности ребер в АТД орграфа, представленного в виде списков смежных вершин, с последующим выполнением поиска в  глубину.
		// Второй, и аналогичный, термин стандартный поиск в глубину на матрице смежности(standard adjacency - matrix DFS) будет обозначать процесс вставки некоторой последовательности ребер в АТД орграфа, представленного в виде матрицы смежности true), с последующим выполнением поиска в глубину.
		// В орграфах имеет место соответствие один к одному между связями дерева и ребрами графа, они попадают в один из четырех различных классов:
		// - Класс ребер, представляющих рекурсивный вызов(древесные(tree) ребра).
		// - Класс ребер, ведущих из той или иной вершины к ее предшественнику в дереве поиска в глубину(обратные(back) ребра).
		// - Класс ребер, ведущих из вершины к потомку в его дереве поиска в глубину (прямые(down) ребра).
		// - Класс ребер, ведущих из одной вершины в другую, не являющуюся ни предшественником, ни потомком в дереве поиска в глубину(поперечные(cross) ребра).
		// Свойство 19.3. В лесе поиска в глубину (DFS), соответствующем орграфу, ребро, которое ведет в посещенную вершину, есть обратное ребро, если оно ведет в узел с более высоким номером при обходе в обратном порядке; в противном случае это поперечное ребро, если оно ведет в узел с более низким номером при обходе в прямом порядке, и прямое ребро, если оно ведет в узел с более высоким номером при обходе в прямом порядке.
		// - Обнаружение направленного цикла. 
		// Существуют ли в заданном орграфе направленные циклы? (Является ли рассматриваемый орграф графом DAG ?)
		// Свойство 19.4. Орграф является графом DAG тогда и только тогда, когда, воспользовавшись алгоритмом поиска в глубину для проверки каждого ребра, мы не сталкиваемся с обратными ребрами.
		// - Достижимость из единственного источника.
		// Свойство 19.5. Посредством рекурсивного поиска в глубину, начинающегося в вершине s, мы можем решить задачу достижимости из единого истока для вершины s за время, пропорциональное числу ребер в подграфе, индуцированном достижимыми вершинами.
		
		// 19.3. Достижимость и транзитивное замыкание 
		// Определение 19.5. Транзитивное замыкание (transitive closure) орграфа есть орграф с теми же вершинами, но ребро из s в t в этом транзитивном замыкании возможно в том и только том случае, когда существует ориентированный путь из s в t в заданном орграфе.
		// Один из привлекательных способов понять транзитивное замыкание основан на представлениях орграфа в виде матрицы смежности и на следующей фундаментальной вычислительной задаче.
		// - Перемножение булевых матриц.
		// for (s = 0; s < V; s++)
		//	for (t = 0; t < V; t++)
		//		for (i = 0, C[s][t] = 0; i < V; i++)
		//			if (A[s][i] && B[i][t])
		//				C[s][t] = 1;
		// Теперь предположим, что А — это матрица смежности орграфа А, и мы используем приведенный выше программный код для вычисления С = А*А = А^2(простая замена в программном коде обозначения В на А).
		// ориентированные ребра в А2 в точности соответствуют ориентированным путям длиной 2 в А.
		// Свойство 19.6. Транзитивное замыкание орграфа можно вычислить путем построения матрицы смежности А этого графа, добавления петли каждой вершины и вычисления А^V.
		// Если мы обнулим главную диагональ матрицы смежности орграфа, квадрат такой матрицы будет представлять собой граф с ребрами, соответствующими каждому пути длиной 2 (вверху).
		// Если установить каждый элемент главной диагонали в 1, то квадрат такой матрицы будет представлять собой граф с ребрами, соответствующий каждому пути длиной 1 пли 2.
		// Мы можем вычислить транзитивное замыкание, применив всего лишь одну операцию такого рода, предусматривающую построение транзитивного замыкания матрицы смежности вместо самой матрицы:
		// for (i = 0; i < V; i++)
		//	for (s = 0; s < V; s++)
		//		for (t = 0; t < V; t++)
		//			if (A[s][i] && A[i][t])
		//				A[s][t] = 1;
		// Свойство 19.7.С помощью алгоритма Уоршалла мы можем вычислить транзитивное замыкание орграфа за время, пропорциональное V^3.
		// ...183
	}
}

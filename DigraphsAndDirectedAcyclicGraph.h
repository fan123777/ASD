#pragma once

namespace nsAlgorithmsOnGraphs
{
	// Орграфы и ориентированные ациклические графы 
	namespace nsDigraphsAndDirectedAcyclicGraph
	{
		void main();
		void test();

		// Если мы придаем значение, в каком порядке описываются две вершины каждого ребра графа, мы получаем совершенно другой комбинаторный объект, известный как ориентированный граф(directed graph), или орграф(digraph).
		// В орграфах обозначение s-t описывает ребро, которое ведет из вершины s в вершину t, но при этом оно не дает никакой информации о том, существует ли ребро, ведущее из t в s.
		// Имеется четыре вида отношений, в которых могут находиться две любые вершины орграфа:
		// связывающее их ребро отсутствует, ребро s - t, ведущее из s в t, ребро t - s, ведущее из t в s, и два ребра s - t и t - s, которые указывают на наличие связи в обоих направлениях.
		// работа с орграфами существенно отличается от работы с неориентированными графами.
		// В этом заключается суть проблемы, известной как задача составления расписаний (scheduling problem).
		// Она не имеет смысла, если в орграфе имеется цикл, в подобного рода ситуациях мы работаем с графами DAG(directed acyclic graph — ориентированный ациклический граф).
		
		// 19.1. Глоссарий и правила игры 
		// Определение 19.1. Ориентированный граф (или орграф) представляет собой некоторый набор вершин плюс некоторый набор ориентированных ребер, которые соединяют упорядоченные пары вершин(при этом дублированные ребра отсутствуют).
		// Мы говорим, что ребро направлено из первой вершины во вторую вершину.
		// Определение 19.2. Ориентированный путь (directed path) в орграфе есть список вершин, в котором имеется(ориентированное) ребро орграфа, соединяющее каждую вершину списка со следующим элементом этого списка.
		// Мы говорим, что вершина t достижима (reachable) из вершины s, если существует ориентированный путь из s в t.
		// Мы принимаем соглашение, согласно которому каждая вершина достижима сама из себя, и обычно реализуем это свойство за счет того, что в представление нашего орграфа включаем петли.
		// Что более важно, для орфафов и графов характерны существенные структурные различия.
		// Например, тот факт, что вершина t достижима из вершины s в орграфе, ничего не говорит о том, достижима ли s из t.
		// Полустепень захода (indegree) вершины орграфа есть число ориентированных ребер, которые ведут в эту вершину.
		// Полустепень исхода (outdegree) вершины орграфа есть число ориентированных ребер, которые исходят из этой вершины.
		// Ни одна из вершин орграфа не достижима из вершины с полустепенью исхода 0, эта вершина получила название сток(sink);
		// вершина с полустепенью захода 0 получила название исток(source), она не достижима ни из одной другой вершины орграфа.
		// Орграфы, в которых допускается существование петель и в которых каждая вершина обладает полустепенью исхода, равной 1, называется картой(mар) (отображение самого на себя множества целых чисел в диапазоне от 0 до V - 1).
		// Обращение (reverse) орграфа - это орграф, который мы получаем, поменяв ориентацию всех ребер орграфа на обратную.
		// Обратите внимание на тот факт, что путь s-t-s есть цикл длиной 2 в орграфе, в то время как цикл в неориентированном графе должен проходить через три различных вершины.
		// Определение 19.3. Ориентированный ациклический граф (directed acyclic graph), или граф DAG, — это орграф, не содержащий направленных циклов.
		// Неориентированный граф связен, если существует путь из каждой его вершины в любую другую вершину;
		// что касается орграфов, то мы модифицируем данное выше определение следующим образом:
		// Определение 19.4. Орграф называется сильно связным(strongly connected), если каждая его вершина достижима из любой другой вершины.
		// Мы говорим, что пара вершин s и t любого графа сильно связана (strongly connected) или что эти вершины являются взаимно достижимыми(mutually reachable), если существует ориентированный путь из s в t и ориентированный путь из t в s.
		// По-другому о том факте, что пара вершин сильно связана, можно сказать следующим образом:
		// они лежат на некотором ориентированном циклическом пути.
		// Обратите внимание на тот факт, что ни один граф DAG, содержащий более одной вершины, не может быть сильно связным.
		// Как и простая связность в неориентированных графах, это отношение транзитивно: 
		// если s сильно связана с t, a t сильно связана с u, то s сильно связана с u.
		// Свойство 19.1. Орграф, не принадлежащий к классу сильно связных графов, содержит некоторый набор сильно связных компонент(strongly connected components) (или, для краткости, strong components — сильных компонент), которые представляют собой максимальные сильно связные подграфы, и некоторый набор ориентированных ребер, идущих от одной компоненты к другой.
		// Свойство 19.2. Пусть задан орграф D, определим еще один орграф K(D), в котором одна вершина соответствует каждой сильной компоненте орграфа D, и одно ребро K(D) соответствует каждому ребру орграфа D, которое соединяет вершины различных сильных компонент(соединяет вершины в К, соответствующие сильным компонентам, которые он соединяет в D).
		// Тогда K(D) будет граф DAG(который мы будем называть базовым графом DAG(kernel DAG), или ядром DAG, графа D).
		// Мы должны исследовать, по меньшей мере, три следующих ситуации:
		// - Связность.
		// Мы зарезервируем термин связный (connected) для неориентированных графов.
		// В случае орграфов мы можем утверждать, что две вершины связаны, если они связаны в неориентированном графе, получаемом, когда направления ребер игнорируются, тем не менее, мы будем избегать подобной трактовки.
		// - Достижимость.
		// Мы говорим, что вершина t орграфа достижима из вершины s, если существует ориентированный путь из s в t.
		// - Сильная связность. 
		// Мы хотим обеспечить поддержку операции АТД орграфа, которые принимают в качестве аргументов две вершины s и t и позволяют нам проверить:
		// - достижима ли t из s; 
		// - существует ли сильная связность вершин s и t (взаимная достижимость). 
		
		// 19.2. Анатомия поиска DFS в орграфах 
		// Основной принцип этого рекурсивного алгоритма можно сформулировать следующим образом:
		// чтобы посетить каждую вершину, достижимую из данной вершины, мы помечаем эту вершину как посещенную, затем(рекурсивно) посещаем все вершины, в которые можно пройти из каждой вершины, внесенные в список смежных с ней вершин.
		// Термин стандартный поиск в глубину на списках смежных вершин(standard adjacency-lists DFS) будет обозначать процесс вставки последовательности ребер в АТД орграфа, представленного в виде списков смежных вершин, с последующим выполнением поиска в  глубину.
		// Второй, и аналогичный, термин стандартный поиск в глубину на матрице смежности(standard adjacency - matrix DFS) будет обозначать процесс вставки некоторой последовательности ребер в АТД орграфа, представленного в виде матрицы смежности true), с последующим выполнением поиска в глубину.
		// В орграфах имеет место соответствие один к одному между связями дерева и ребрами графа, они попадают в один из четырех различных классов:
		// - Класс ребер, представляющих рекурсивный вызов(древесные(tree) ребра).
		// - Класс ребер, ведущих из той или иной вершины к ее предшественнику в дереве поиска в глубину(обратные(back) ребра).
		// - Класс ребер, ведущих из вершины к потомку в его дереве поиска в глубину (прямые(down) ребра).
		// - Класс ребер, ведущих из одной вершины в другую, не являющуюся ни предшественником, ни потомком в дереве поиска в глубину(поперечные(cross) ребра).
		// Свойство 19.3. В лесе поиска в глубину (DFS), соответствующем орграфу, ребро, которое ведет в посещенную вершину, есть обратное ребро, если оно ведет в узел с более высоким номером при обходе в обратном порядке; в противном случае это поперечное ребро, если оно ведет в узел с более низким номером при обходе в прямом порядке, и прямое ребро, если оно ведет в узел с более высоким номером при обходе в прямом порядке.
		// - Обнаружение направленного цикла. 
		// Существуют ли в заданном орграфе направленные циклы? (Является ли рассматриваемый орграф графом DAG ?)
		// Свойство 19.4. Орграф является графом DAG тогда и только тогда, когда, воспользовавшись алгоритмом поиска в глубину для проверки каждого ребра, мы не сталкиваемся с обратными ребрами.
		// - Достижимость из единственного источника.
		// Свойство 19.5. Посредством рекурсивного поиска в глубину, начинающегося в вершине s, мы можем решить задачу достижимости из единого истока для вершины s за время, пропорциональное числу ребер в подграфе, индуцированном достижимыми вершинами.
		
		// 19.3. Достижимость и транзитивное замыкание 
		// Определение 19.5. Транзитивное замыкание (transitive closure) орграфа есть орграф с теми же вершинами, но ребро из s в t в этом транзитивном замыкании возможно в том и только том случае, когда существует ориентированный путь из s в t в заданном орграфе.
		// Один из привлекательных способов понять транзитивное замыкание основан на представлениях орграфа в виде матрицы смежности и на следующей фундаментальной вычислительной задаче.
		// - Перемножение булевых матриц.
		// for (s = 0; s < V; s++)
		//	for (t = 0; t < V; t++)
		//		for (i = 0, C[s][t] = 0; i < V; i++)
		//			if (A[s][i] && B[i][t])
		//				C[s][t] = 1;
		// Теперь предположим, что А — это матрица смежности орграфа А, и мы используем приведенный выше программный код для вычисления С = А*А = А^2(простая замена в программном коде обозначения В на А).
		// ориентированные ребра в А2 в точности соответствуют ориентированным путям длиной 2 в А.
		// Свойство 19.6. Транзитивное замыкание орграфа можно вычислить путем построения матрицы смежности А этого графа, добавления петли каждой вершины и вычисления А^V.
		// Если мы обнулим главную диагональ матрицы смежности орграфа, квадрат такой матрицы будет представлять собой граф с ребрами, соответствующими каждому пути длиной 2 (вверху).
		// Если установить каждый элемент главной диагонали в 1, то квадрат такой матрицы будет представлять собой граф с ребрами, соответствующий каждому пути длиной 1 пли 2.
		// Мы можем вычислить транзитивное замыкание, применив всего лишь одну операцию такого рода, предусматривающую построение транзитивного замыкания матрицы смежности вместо самой матрицы:
		// for (i = 0; i < V; i++)
		//	for (s = 0; s < V; s++)
		//		for (t = 0; t < V; t++)
		//			if (A[s][i] && A[i][t])
		//				A[s][t] = 1;
		// Свойство 19.7.С помощью алгоритма Уоршалла мы можем вычислить транзитивное замыкание орграфа за время, пропорциональное V^3.
		// Мы используем термин абстрактное транзитивное замыкание (abstract transitive closure) для обозначения АТД, который предоставляет клиентам возможность проверки после предварительной обработки графа.
		// Свойство 19.8. Мы можем поддерживать выполнение проверки заданного орграфа на достижимость(абстрактное транзитивное замыкание) за постоянное время ценой затрат пространства памяти, пропорционального V^2, и времени, пропорционального V^3, затрачиваемого на предварительную обработку.
		// Прежде всего, мы рассмотрим отношение между транзитивным замыканием и задачей определения кратчайших путей для всех пар вершин(all - pairs shortest - paths).
		// Свойство 19.9. Мы можем использовать алгоритм транзитивного замыкания для вычисления произведения двух булевых матриц, при этом различие во времени исполнения не превышает некоторого постоянного коэффициента.
		// Свойство 19.10. С помощью DFS мы можем поддерживать постоянное время ответа на запросы относительно абстрактного транзитивного замыкания орграфа, затрачивая пространство памяти, пропорциональное V2, и время, пропорциональное V(E + V), на предварительную обработку(вычисление транзитивного замыкания).
		
		// 19.4.Отношения эквивалентности и частичные порядки
		// Пусть задано некоторое множество.
		// По определению, отношение (relation), в котором находятся его объекты, есть множество упорядоченных пар этих объектов.
 		// Обычно мы выбираем символ R и используем выражение sRt для обозначения утверждения "упорядоченная пара (s,t) находится в отношении R".
		// - отношение R называется симметричным, если из sRt следует tRs для всех s и t;
		// - говорят, что отношение рефлексивно, если sRs справедливо для всех s.
		// - говорят, что отношение транзитивно, когда из sRt и tRu следует sRu для всех s, t и u.
		// В контексте алгоритмов на графе особый интерес вызывает у нас два специальных транзитивных отношения:
		// отношения эквивалентности(equivalence relations) и частичные порядки(partial orders).
		// Отношение эквивалентности (=) есть транзитивное отношение, которое к тому же рефлексивно и симметрично.
		// Отношение эквивалентности разносит объекты множества по подмножествам, известным как классы эквивалентности(equivalence class).
		// Типичными примерами эквивалентности могут служить следующие отношения:
		// - Арифметика над абсолютными значениями чисел.
		// - Связность в графах.
		// Частичный порядок (partial order) -< есть транзитивное нерефлексивное отношение.
		// частичные порядки асимметричны.
		// Следующие примеры представляют собой типичные частичные порядки:
		// - Включение подмножеств. 
		// - Пути в графах DAG.
		// Полный порядок (total order) T есть частичный порядок, при котором выполняется либо sTt, либо tTs, s != t.
		// - Отношения и орграфы.
		// - Симметричные отношения и неориентированные графы.
		// - Транзитивные отношения и пути в графах.
		// - Отношения эквивалентности и пути в неориентированных графах.
		// - Частичные порядки и пути в графах DAG.

		// 19.5 Графы DAG 
		// В этом разделе мы рассмотрим различные приложения графов DAG (directed acyclic graph - ориентированный ациклический граф).
		// Во-первых, они служат неявными моделями частичных порядков; во многих приложениях мы имеем дело непосредственно с графами DAG, и в силу этого обстоятельства нуждаемся в эффективных алгоритмах обработки таких графов.
		// Во-вторых, различные приложения дают нам возможность постижения природы графов DAG, а понимание графов DAG существенно упрощает понимание общих свойств орграфов.
		// И наоборот, осознание сложности обработки графов DAG важно с той точки зрения, что каждый орграф содержит некоторый DAG в качестве своего ядра.
		// Приложение-прототип, в котором графы DAG возникают сами по себе, называется приложением составления расписаний(scheduling).
		// В общем случае решение задачи составления расписаний заключается в организации завершения решения некоторого множества задач(tasks) в условиях действия некоторого набора ограничений(constraints) путем задания условий, когда и как эти задачи должны выполняться.
		// Наиболее важным типом ограничений является ограничения предшествования (precedence constraints), которые определяют, что одни задачи должны быть обязательно решены до того, как может быть начато решение других задач, благодаря чему на множество задач устанавливается некоторый частичный порядок.
		// - Составление расписаний. 
		// Пусть дано множество задач, требующих решения, на котором задан частичный порядок, определяющий, что решение некоторых задач должны быть завершено, прежде чем начнется выполнение некоторых других задач.
		// Каким образом можно организовать решение всех задач множества так, чтобы в конечном итоге все они были успешно завершены с соблюдением частичного порядка?
		// В своем основном виде задача составления расписания называется топологической сортировкой(topological sorting);
		// Еще один пример: задачи могут быть частью некоторого производственного процесса, при этом частичный порядок представляет собой требования к последовательности, в которой выполняются конкретные процессы.
		// Определение 19.6. Двоичный DAG (binary DAG) есть ориентированный ациклический граф с двумя ребрами, исходящими из каждого узла, которые рассматриваются как левое и правое ребро, при этом каждое из них или оба сразу могут быть нулевыми.
		// Двоичный DAG есть модель экономичной схемы, которая вычисляет эту функцию.
		// В таком приложении двоичные графы DAG называются схемами BDD(binary decision diagram — двоичная схема решений).
		
		// 19.6. Топологическая сортировка
		// Цель топологической сортировки заключается в том, чтобы подготовить обработку вершин графа DAG таким образом, чтобы каждая вершина была обрабо тана до того, как будут обработаны все вершины, на которые она указывает.
		// Обе задачи требуют перестановки целых чисел от 0 до V - 1, которые мы, как обычно, помещаем в векторы, индексированные именами вершин.
		// - Топологическая сортировка (с переименованием). 
		// Пусть задан некоторый DAG, нужно переименовать его вершины таким образом, чтобы каждое ориентированное ребро вело из вершины с меньшим номером в вершину с большим номером.
		// - Топологическая сортировка (с перегруппировкой).
		// Пусть задан некоторый DAG, нужно перегруппировать его вершины по горизонтали таким образом, чтобы все ориентированные ребра были направлены слева направо.
		// Например, если в векторе ts вершины размещены в порядке топологической сортировки, то цикл
		// for (i = 0; i < V; i++) tsI[ts[i]] = i;
		// определяет переименование в векторе tsl, индексированном именами вершин.
		// И наоборот, мы можем получить перегруппировку из переименования с помощью цикла
		// for (i = 0; i < V; i++) ts[tsl[i]] = i;
		// Теперь выясняется, что мы уже рассматривали алгоритм обратной топологической сортировки, таковым является наш старый знакомый — стандартный рекурсивный поиск в глубину!
		// Если на вход подать DAG, то нумерация вершин во время обхода в обратном порядке размещает вершины в порядке обратной топологии.
		// Свойство 19.11. Нумерация при обходе в обратном порядке при поиске в глубину представляет собой обратную топологическую сортировку для любого графа DAG.
		// Таким образом, мы легко можем заставить стандартный поиск в глубину выполнять топологическую сортировку.
		// С точки зрения вычислений, различия между топологической сортировкой и обратной топологической сортировкой не критичны.
		// Мы просто можем изменить операцию [] так, чтобы она возвращала значение postI[G.V() - l - v], либо модифицировать реализацию одним из следующих способов:
		// - Выполнить обратную топологическую сортировку на обращении заданного графа DAG.
		// - Вместо того чтобы использовать номер вершины в качестве индекса при нумерации в обратном порядке, следует затолкнуть номер вершины в стек как завершающее действие рекурсивной процедуры.После завершения просмотра вытолкните вершины из стека.
		// Они выходят из стека в топологическом порядке.
		// - Пронумеруйте вершины в обратном порядке (начните с V-1 и выполните отсчет до 0).
		// При желании вычислите обратную нумерацию вершин, чтобы получить топологический порядок.
		// Далее мы рассмотрим альтернативный классический метод топологической сортировки, которые имеет определенное сходство с BFS(breadth - first search — поиск в ширину)
		// Он основан на следующем свойстве фафа DAG.
		// Свойство 19.12. У каждого графа DAG имеется, по меньшей мере, один исток и, по меньшей мере, один сток.
		// Из этого факта мы можем вывести алгоритм топологической сортировки: пометим любой исток наименьшей неиспользованной меткой, затем удалим его и пометим остальную часть графа DAG, применив тем же алгоритм.
		// Эффективная реализация этого алгоритма есть классический пример алгоритма топологической сортировки
		// Во-первых, возможно, существование некоторого множества истоков, и в силу этого обстоятельства для их отслеживания мы должны поддерживать очередь.
		// Во-вторых, мы должны выявить в заданном графе DAG истоки, которые остаются после удаления того или иного истока.
		// Мы можем решить эту задачу, поддерживая вектор, проиндексированный именами вершин, который отслеживает полустепень захода каждой вершины.
		// пока очередь истоков не опустеет, мы выполняем следующие операции:
		// - Удаляем исток из очереди и присваиваем ему соответствующую метку.
		// - Уменьшаем на единицу значения элементов вектора полустепеней захода, соответствующих вершинами назначения каждого из ребер удаленной вершины.
		// - Если в результате уменьшения значения какой - либо элемент принимает значение 0, вставляем соответствующую вершину в очередь истоков.
		// Классическим примером может служить задача определения длины самого длинного пути в фафе DAG.
		// Рассматривая вершины в порядке, обратном устанавливаемому топологической сортировкой, легко вычислить самый длинный путь, начинающийся в каждой вершине v.
		// Всякий раз, когда мы используем топологическую сортировку для подобного рода приложений, перед нами встает проблема выбора одного из следующих способов разработки реализации:
		// - Использование класса DAGts в АТД DAG с последующей обработкой вершин в очередности, задаваемой вектором, который он вычисляет.
		// - Обработка вершин после рекурсивных вызовов в рамках DFS.
		// - Обработка вершин по мере того, как они выбираются из очереди в процессе топологической сортировки на базе очереди истоков.

		// 19.7 Достижимость в графе DAG
		// Мы завершим наше изучение графов DAG рассмотрением задачи вычисления транзитивного замыкания DAG.
		// Свойство 19.13. С помощью динамического программирования и поиска в глубину мы можем обеспечить постоянное время ответа на запрос на абстрактное транзитивное замыкание графа DAG, при этом на предварительную обработку(для подготов ки вычисления транзитивного замыкания) затрачи вается пространство памяти, пропорциональное V^2, и время, пропорциональное V^2 + V*X, где X - это число поперечных ребер в лесе DFS.

		// 19.8. Сильные компоненты в орграфах 
		// Чтобы изучить структуру орграфов, рассмотрим сильную связность (strong connectivity), обладающую интересующей нас симметрией.
		// вершины орграфа разбиваются на классы сильных компонент, состоящие из взаимно достижимых компонент.
		// В этом разделе мы рассмотрим три алгоритма поиска сильных компонент в орграфах.
		// ...214
	}
}

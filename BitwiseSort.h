#pragma once

#include "Common.h"

namespace nsSorting
{
	// Поразрядная сортировка
	namespace nsBitwiseSort
	{
		void main();

		const int bitsword = 32;
		const int bitsbyte = 8;
		const int bytesword = bitsword / bitsbyte;
		const int R = 1 << bitsbyte;

		inline int digit(long A, int B);
		inline int digit1(char* A, int B);
		
		template<typename Item>
		inline int digit2(Item& A, int B)
		{
			return A.str[B];
		}

		// Программа 10.1.Двоичная быстрая сортировка
		template <class Item>
		void quicksortB(Item a[], int l, int r, int d)
		{
			int i = l, j = r;
			if (r <= l || d > bitsword)
				return;
			while (j != i)
			{
				while (digit(a[i], d) == 0 && (i < j)) i++;
				while (digit(a[j], d) == 1 && (j > i)) j--;
				nsCommon::exch(a[i], a[j]);
			}
			if (digit(a[r], d) == 0)
				j++;
			quicksortB(a, l, j - 1, d + 1);
			quicksorts(a, j, r, d + 1);
		}

		template <class Item>
		void sort(Item a[], int l, int r)
		{
			quicksortB(a, l, r, 0);
		}

		// Программа 10.2.Поразрядная сортировка MSD
		#define bin(A) l+count[A]
		template <class Item>
		void radixMSD(Item a[], int l, int r, int d)
		{
			int i, j, count[R + 1];
			const maxN = 1000;
			const int M = 25;
			static Item aux[maxN];
			if (d > bytesword)
				return;
			if (r - l <= M)
			{
				nsCommon::insertion(a, l, r);
				return;
			}
			for (j = 0; j < R; j++)
				count[j] = 0;
			for (i = l; i <= r; i++)
				count[digit(a[i], d) + 1]++;
			for (j = 1; j < R; j++)
				count[j] += count[j - 1];
			for (i = l; i <= r; i++)
				aux[l + count[digit(a[i], d)]++] = a[i];
			for (i = l; i <= r; i++)
				a[i] = aux[i];
			radixMSD(a, l, bin(0) - 1, d + 1);
			for (j = 0; j < R - 1; j++)
				radixMSD(a, bin(j), bin(j + l) - l, d + 1);
		}

		// Программа 10.3.Трехпутевая поразрядная быстрая сортировка
		// - ссылки на ключи становятся ссылками на конкретные байты ключей,
		// - текущий байт добавляется как параметр к рекурсивной служебной программе
		// - рекурсивные вызовы для среднего подфайла перемещаются к следующему байту.
		#define ch(A) digit(A, d)
		template <class Item>
		void quicksorts(Item a[], int l, int r, int d)
		{
			int i, j, k, p, q; int v;
			const int M = 25;
			if (r - l <= M)
			{
				nsCommon::insertion(a, l, r);
				return;
			}
			v = ch(a[r]); i = l - 1; j = r; p = l - 1; q = r;
			while (i < j)
			{
				while (ch(a[++i]) < v);
				while (v < ch(a[--j]))
				if (j == l)
					break;
				if (i > j)
					break;
				nsCommon::exch(a[i], a[j]);
				if (ch(a[i]) == v)
				{
					p++;
					nsCommon::exch(a[p], a[i]);
				}
				if (v == ch(a[j]))
				{
					q--;
					nsCommon::exch(a[j], a[q]);
				}
				if (p == q)
				{
					if (v != "\0") quicksortX(a, l, r, d + 1);
					return;
				}
				if (ch(a[i]) < v)
					i++;
				for (k = l; k <= p; k++, j--)
					nsCommon::exch(a[k], a[j]);
				for (k = r; k >= q; k--, i++)
					nsCommon::exch(a[k], a[i]);
				quicksortX(a, l, j, d);
				if ((i == r) && < (ch(a[i]) == v))
					i++;
				if (v != "\0")
					quicksortX(a, j + 1, i - 1, d + 1);
				quicksortX(a, i, r, d);
			}
		}
		
		// Программа 10.4.Метод поразрядной сортировки LSD
		template <class Item>
		void radixLSD(Item a[], int l, int r)
		{
			int maxN = 100;
			static Item aux[maxN];
			const int R = 3;
			for (int d = bytesword - 1; d >= 0; d--)
			{
				int i, j, count[R + l];
				for (j = 0; j < R; j++)
					count[j] = 0;
				for (i = l; i <= r; i++)
					count[digit(a[i], d) + 1]++;
				for (j = 1; j < R; j++)
					count[j] += count[j - l];
				for (i = l; i <= r; i++)
					aux[count[digit(a[i], d)]++] = a[i]
				for (i = l; i <= r; i++)
					a[i] = aux[i];
			}
		}

		// В данной главе мы займемся изучением еще одной абстракции, отличной от рассмотренных выше, применительно к ключам сортировки.
		// Например, довольно часто нет необходимости в обработке ключей в полном объеме на каждом этапе:
		// чтобы найти телефонный номер какого - либо конкретного абонента вполне достаточно проверить несколько первых букв его фамилии, чтобы найти страницу, на которой на ходится искомый номер.
		// Методы сортировки, построенные на обработке чисел по одной порции за раз, называются поразрядными(radix) методами сортировки.
		// Эти методы не только выполняют сравнение ключей : они обрабатывают и сравнивают соответствующие части ключей.
		// Алгоритмы поразрядной сортировки рассматривают ключи как числа, представленные в системе счисления с основанием R при различных значениях R(основание системы счисления), и работают с отдельными цифрами чисел.
		// В основе алгоритмов поразрядной сортировки лежит абстрактная операция извлечь из ключа i-ю цифру.
		// Существуют два принципиально различных базовых подхода к поразрядной сортировке.
		// - Первый класс методов составляют алгоритмы, которые анализируют значение цифр в ключах в направлении слева направо, при этом первыми обрабатываются наиболее значащие цифры.
		// Такие методы в общем случае называются поразрядной сортировкой MSD(most significant digit radix sort - Поразрядная сортировка сначала по старшей цифре).
		// В самом деле, в условиях, когда в качестве основания системы счисления выбрана 2, мы реализуем поразрядную сортировку MSD тем же способом, что и быструю сортировку.
		// - Во втором классе методов поразрядной сортировки используется другой принцип :
		// они анализируют цифры ключей в направлении справа налево, работая с сначала с наименее значащей цифрой.
		// Эти методы в общем случае называются поразрядной сортировкой LSD(least significant digit radix sort - Поразрядная сортировка сначала по младшей цифре).
		
		// 10.1. Биты, байты и слова 
		// Ключевое условие для понимания сути поразрядной сортировки состоит в признании того, что
		// 1) компьютеры в общем случае ориентированы на обработку групп битов, называемых машинными словами, которые в свою очередь часто объединяются в небольшие фрагменты, называемые байтами;
		// 2) ключи сортировки обычно также организуются в последовательности байтов;
		// 3) короткие последовательности байтов могут также служить индексами массивов или машинными адресами.
		// Определение 10.1. Байт представляет собой последовательность битов фиксированной длины, строка есть последовательность байтов переменной длины, слово есть последовательность байтов фиксированной длины.
		// В большинстве компьютеров реализованы битовые операции и(and) и сдвиг(shift), которыми мы можем воспользоваться для извлечения отдельных байтов из слов.
		// В C++ мы можем прямо написать операции извлечения B-ого байта из двоичного A слова следующим образом:
		// Определение 10.2. Ключ есть число в системе счисления с основанием R, цифры которого пронумерованы слева(начиная с 0).
		// В самом деле, расчеты, связанные подсчетом индексных ключей, лежат в основе базовых методов поразрядной сортировки MSD и LSD.
		// Поразрядная сортировка вступает на передний план, когда ключи обладают достаточной длиной(скажем, w = 64), когда использование таблицы размером 2^w не является целесообразным.

		// 10.2.Двоичная быстрая сортировка
		// Предположим, что мы можем переупорядочить записи в файле таким образом, что все те ключи, которые начинаются с бита 0, идут раньше всех тех, которые начинаются с бита 1.
		// Далее мы можем воспользоваться методом рекурсивной сортировки, который является одним из вариантов быстрой сортировки:
		// разбиение файла этим способом с последующей независимой сортировкой двух полученных подфайлов.
		// Чтобы переупорядочить файл, выполните просмотр слева с целью обнаружить ключ, который начинается с бита 1, затем продолжайте просмотр справа с целью найти ключ, который начинается с бита 0, поменяйте ключи местами и продолжайте процесс до тех пор, пока указатели не пересекутся.
		// Этом метод в литературе часто называют поразрядной обменной сортировкой с тем, чтобы подчеркнуть, что это прежде всего простой вариант алгоритма, изобретенного Хоаром, несмотря на то что он был открыт раньше быстрой сортировки.
		// Такая структура обладает следующим свойством:
		// продвигаясь по пути от корня к конкретному ключу, принимая 0 за левую ветвь и 1 за правую ветвь, получаем значения старших разрядов этого ключа.
		// Мы можем внести усовершенствования в базовую рекурсивную реализацию, представленную программой 10.1, за счет отказа от рекурсии и обработки подфайлов небольших размеров другим способом, как это делалось в случае стандартной быстрой сортировки в главе 7.
		
		// 10.3. Поразрядная сортировка MSD
		// Чтобы сделать это, необходимо разделить массив по крайней мере на R, а не на 2, различных частей.
		// По традиции будем называть эти разделы корзинами или ведрами и будем представлять себе рассматриваемый алгоритм как группу из R корзин, по одной на каждое возможное значение первой цифры.
		// Мы выполняем проход по всем ключам, распределяя их по корзинам, затем выполняем сортировку содержимого корзины по ключам с байтами, которые меньше исходных на 1.
		// Мы распределяем множество слов по 26 корзинам соответственно первой букве.
		// Затем мы сортируем каждую корзину, применяя тот же метод, начиная со второй буквы.
		// Более того, мы можем настроить алгоритм соответствующим образом путем выбора значения R, поскольку существует простая зависимость:
		// если R принимает чрезмерно большое значение, то большая часть стоимости сортировки приходится на инициализацию и проверку корзин, если наоборот, R недостаточно велико, то метод не использует своих потенциальных выгод, что достигается, если разделить исходный файл на максимально возможное число фрагментов.
		// К счастью, метод подсчета индексных ключей, который рассматривался в главе 6 для целей сортировки файлов с ключами, принимающих значения в узком диапазоне, в рассматриваемом случае подходит как нельзя лучше.
		// Другой естественный путь реализации поразрядной сортировки MSD предполагает использование связных списков.
		// Для каждой корзины предусматривается один связный список:
		// на первом проходе по сортируемым элементам мы вставляем элемент в соответствующий связный список, определяемый цифрой старшего разряда.
		// Далее мы сортируем подсписки, после чего объединяем все эти связные списки в единое целое.
		// Соединение связных списков требует отслеживания начала и конца каждого из этих списков, и, естественно, многие из них вполне могут оказаться пустыми.
		// Короче говоря, вполне очевидно, что мы не должны использовать большие основания систем счисления в условиях поразрядной сортировки MSD файлов небольших размеров.
		// Если мы положим R = 256 и откажемся от рекурсивного вызова для корзины 0, топрограмма 10.2 становится эффективным методом сортировки строк в стиле С.
		// Структура вызова соответствует многопутевому бинарному дереву, прямому обобщению древовидной структуры для двоичной быстрой сортировки.
		// Один из практических способов решения этой проблемы заключается в разработке более сложной реализации абстрактной операции доступа к конкретным байтам, которая учитывает любые специальные знания о сортируемых строках.
		// Другим методом, который достаточно просто реализуется и который называется эвристика в масштабах корзины(bin-span-heuristics) заключается в том, что запоминаются начальные и конечные значения диапазонов значений непустых корзин на стадии подсчета, а затем используются только корзины, попадающие в полученный диапазон(возможно, с учетом некоторых специальных случаев, таких как специальные значения ключей, например, 0 или пробел).
		
		// 10.4. Трехпутевая поразрядная быстрая сортировка
		// Еще одна возможность приспособить быструю сортировку для поразрядной сортировки MSD заключается в использовании трехпутевого разделения ключей по старшим байтам, переходя к следующему байту только в среднем подфайле(в котором содержатся ключи, старшие байты которых равны старшему байту разделяющего элемента).
		// этот метод работает в  ln(N) раз быстрее, чем обычная быстрая сортировка, если принимать во внимание только стоимость операций сравнения.
		// После выполнения настройки программы 10.3 на это приложение, мы будем называть ее многомерной быстрой сортировкой(multikey quicksort).
		
		// 10.5. Поразрядная сортировка LSD
		// метод сортировки с подсчетом индексных ключей является устойчивым методом сортировки, что сразу же приводит нас к классическому и эффективному алгоритму.

		// 10.6.Рабочие характеристики поразрядных сортировок
		// Лемма 10.1. В худшем случае поразрядная сортировка выполняет проверку всех байтов и всех ключей.
		// Для ключей произвольной длины справедливо следующее утверждение:
		// Лемма 10.2. Двоичная быстрая сортировка в среднем производит проверку N*lg(N) разрядов при сортировке ключей, состоящих их битов, принимающих случайное значение.
		// Лемма 10.3. Поразрядная сортировка MSD с основанием системы счисления R применительно к файлу размера N требует для выполнения по меньшей мере 2N + 2R шагов.
		// Лемма 10.4. Если основание системы счисления всегда меньше размера файла, то в худшем случае число шагов, выполняемых поразрядной сортировкой MSD, учитывается постоянным множителем небольшой величины при log_r(N) для ключей, содержащих случайслучайные байты) и постоянным множителем небольшой величины при числе байтов в ключе.
		// Лемма 10.5. Трехпутевая поразрядная быстрая сортировка выполняет в среднем 2Nlog(N) операций сравнения байтов при сортировке N ключей(произвольной длины).
		// Лемма 10.6. Поразрядная сортировка LSD может сортировать N записей с w-разрядными ключами за w / lg(R) проходов, при этом используется дополнительное пространство памяти для R счетчиков(и буфер для переупорядочения файла).
		
		// 10.7. Сортировки с сублинейным временем выполнения
		// Целесообразно выбирать R таким, чтобы значение ln(R) (число разрядов в байте) было примерно равно одной четвертой от размера слова, так чтобы поразрядная сортировка представляла собой четыре прохода сортировки методом подсчета индексных ключей.
		// В действительности дело обстоит так, что мы можем обойтись всего лишь двумя проходами процедуры подсчета индексных ключей.
		// Мы сделаем это, воспользовавшись тем фактом, что файл будет практически отсортирован, если используются только w / 2 старших разрядов w - разрядных ключей.
		// Как это имело место в случае быстрой сортировки, можно эффективно завершить сортировку, выполнив после этого сортировку простыми вставками для всего файла.
		// Подход применительно к поразрядной сортировке получил широкое распространение в силу того, что он требует исключительно простых структур управления, а его базовые операции очень удобны для реализаций в машинном языке, который легко адаптируется к высокопроизводительным аппаратным средствам специального назначения.
	}
}

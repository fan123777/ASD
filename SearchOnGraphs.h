#pragma once

#include <vector>

namespace nsAlgorithmsOnGraphs
{
	// Поиск на графе 
	namespace nsSearchOnGraphs
	{
		void main();

		void test();


		// В данной главе мы рассматриваем фундаментальные алгоритмы поиска на графах(graph search), которые используются для перемещения по графам, с изучением по мере продвижения его структурных свойств.
		// В частности, рекурсивный алгоритм DFS (depth-first search - поиск в глубину) точно соответствует конкретпой стратегии исследования лабиринта.
		// Возможны 2 реализации этого базового алгоритма; одна в виде рекурсивной процедуры и другая - с использованием явно заданного стека.
		// Замена стека очередью FIFO (First in First Out - первым пришел, первым обслужен) приводит к другому классическому алгоритму — к алгоритму BFS(breadth - first search - поиск в ширину), который используется для решения других задач обработки графов, связанных с нахождением кратчайших путей.
		// Основной темой, рассматриваемой в данной главе, являются алгоритмы поиска в глубину, поиска в ширину и другие связанные с ними алгоритмы, а также их применение при обработке графов.

		// 18.1. Исследование лабиринта
		// Использование терминов лабиринт(maze) вместо граф, коридор(passage) вместо ребро и перекресток (intersection) вместо вершина есть ни что иное, как просто семантическое различие, однако на данной стадии переход на другую терминологию поможет глубже прочувствовать задачу.
		// Один из приемов, заключается в том, чтобы разматывать клубок по мере продвижения вглубь лабиринта.
		// Следующая стратегия исследования лабиринта, которую мы будем называть исследованием Тремо(Tremaux exploration), известна, по меньшей мере, с девятнадцатого столетия:
		// 1) Если на текущем перекрестке нет закрытых дверей, переходите к шагу(3).
		// В противном случае откройте любую дверь любого коридора, ведущую из текущего перекрестка(и оставьте ее открытой).
		// 2) Если вы видите, что лампа, установленная на перекрестке на другом конце этого коридора уже включена, попробуйте открыть другую дверь на текущем перекрестке(шаг(1)).
		// Иначе(если вы видите, что перекресток на другом конце соответствующего коридора не освещен), проследуйте по коридору к этому перекрестку, разматывая при этом нить, включите свет и переходите к шагу(1).
		// 3) Если все двери на текущем перекрестке открыты, проверьте, не находитесь ли вы в отправной точке.
		// Если да, то процесс окончен.
		// Если нет, воспользуйтесь нитью, чтобы двигаться назад вдоль коридора, который привел вас в этот перекресток в первый раз, разматывая нить по мере продвижения, и ищите другую замкнутую дверь уже там(т.е.вернитесь к шагу(1).
		// Свойство 18.1.Когда мы проводим исследование Тремо некоторого лабиринта, мы зажигаем все лампы и открываем все двери в лабиринте и завершаем обход там, где его начинали.
		// мы видим, что существуют четыре различных ситуаций, которые возникают при выборе очередного коридора и которые мы должны учитывать, принимая одно из возможных решений:
		// 1) Коридор не освещен, следовательно, мы его выбираем.
		// 2) Коридор уже был использован (в нем мы размотали нить), следовательно, мы выбираем его (и сматываем нить в клубок).
		// 3) Дверь на другом конце коридора закрыта (но сам перекресток освещен), в силу этого обстоятельства мы пропускаем этот коридор.
		// 4) Дверь на другом конце коридора открыта (а перекресток освещен), в силу этого обстоятельства мы пропускаем этот коридор.
		
		// 18.2. Поиск в глубину
		// посетив конкретную вершину, мы помечаем ее специальной меткой, свидетельствующей о том, что она посещена, затем, в режиме рекурсии, мы посещаем все смежные с нею вершины, которые еще не были помечены.
		// метода поиска в глубину (DFS — depth-first search).
		// Это дерево рекурсивных вызовов, известное как дерево DFS, обеспечивает структурное описание процесса поиска.
		// Порядок обхода вершин зависит не только от графа, но и от его представления и реализации АТД.
		// Несмотря на все эти возможности, критичным остается тот факт, что алгоритм поиска в глубину посещает все ребра и все вершины, связанные с исходной вершиной, независимо от того, в какой последовательности он проверяет ребра, инцидентные каждой вершине.
		
		// 18.3. Функции АТД поиска на графе 
		// переход от вершины к вершине вдоль ребер может провести через все вершины только в рамках одной и той же связной компоненты, которой принадлежит исходная вершина.
		// Обычно мы используем функции поиска на графе, которые, пока все вершины графа не будут помечены как посещенные, выполняют следующие действия:
		// - Найти непомеченную вершину (отправная вершина).
		// - Посетить (и пометить как посещенные) все вершины в связной компоненте, которая содержит отправную вершину.
		// Свойство 18.2. Функция поиска на графе проверяет каждое ребро и помечает каждую вершину заданного графа тогда и только тогда, когда функция поиска, которую использует граф, помечает каждую вершину и проверяет каждое ребро связной компоненты, содержащей исходную вершину.
		// Свойство 18.3: Поиск в глубину на графе, представленном матрицей смежности, требует времени, пропорционального V^2.
		// Свойство 18.4: Поиск в глубину на графе, представленного списками смежных вершин, требует времени, пропорционального V + Е.
		// В качестве соглашения будем полагать, что все векторы, индексированные именами вершин, инициализируются в функциях поиска на графе минус единицей(-1), а все компоненты этого вектора, соответствующие посещенным вершинам, в функциях поиска на графе принимают неотрицательные значения.
		// В силу специфики примеров и упражнений, в данной книге употребляется термин стандартный DFS по спискам смежных вершин(standard adjacency - lists DFS) для обозначения процесса вставки последовательности ребер в АТД графа, реализованного на основе построения представления графа в виде списков смежных вершин с последующим выполнением поиска в глубину.
		// В случае представления графа в виде матрицы смежности порядок вставки ребер не влияет на динамику поиска, тем не менее, мы будем пользоваться параллельным термином стандартный DFS по матрице смежности(standard adjacency - matrix DFS) для обозначения процесса вставки последовательности ребер в АТД графа, реализованного на основе построения представления графа в виде матрицы смежности споследующим выполнением DFS.
		
		// 18.4. Свойства лесов DFS
		// Чтобы изучить более сложные свойства графа, проведем классификацию ребер графа в соответствии с той ролью, которую они играют в поиске.
		// Имеются два четко определенных класса ребер:
		// - ребра, представляющие рекурсивные вызовы (древесные ребра - tree edges);
		// - ребра, соединяющие конкретную вершину с ее предшественником в дереве DFS, который не является ее родителем(обратные ребра — back edges)).
		// Вектор ord определяет последовательность, в которой мы посещаем вершины дерева во время обхода в прямом порядке и который аналогичен последовательности посещения вершин графа алгоритмом DFS.
		// Вектор st является представлением в виде родительских связей дерева рекурсивных вызовов поиска в глубину.
		// Поскольку существуют два представления каждого ребра графа, и каждое ребро соответствует связи в дереве DFS, разделим связи дерева на четыре класса, воспользовавшись номерами предпорядка(preorder number) и родительскими связями(соответственно, в массивах ord и st), которые вычисляет наша программа поиска в глубину.
		// Мы рассматриваем связь между вершинами v и w в дереве DFS, которая представляет ребро дерева, как:
		// - древесная связь (tree link), если v не помечена;
		// - родительская связь (parent link), если st[w] есть v,
		// а связь от v к w, которая представляет обратное ребро как
		// - связь назад (back link), если ord[w] < ord[v];
		// - связь вниз (down link), если ord[w] > ord[v].
		// При обходе графов с помощью поиска в глубину мы использовали вектор ort для присвоения вершинам номеров в прямом порядке, т.е. для присвоения номеров в той последовательности, в какой мы приступаем к их обработке.
		// Мы будем также присваивать вершинам номера в обратном порядке(postorder numbers), т.е.номера в той последовательности, в какой мы завершаем их обработку(непосредственно перед выходом из функции рекурсивного поиска).
		// число связных компонент графа равно числу деревьев в лесе DFS.
		// разнообразие реализаций классов обработки графов основано на изучении свойств графа путем обработки конкретного его представления(лес, соответствующий поиску).
		// Векторы ord и st зависят от представления графа и динамики поиска.
		// - Существует, по меньшей мере, один длинный путь, который соединяет существенную часть узлов.
		// - Во время поиска большая часть вершин имеет, по меньшей мере, одну смежную вершину, которую мы еще не видели.
		// - Мы редко делаем более одного рекурсивного вызова с одного узла.
		// - Глубина рекурсии пропорциональна числу вершин графа.
		
		// 18.5 Алгоритмы DFS
		// - Обнаружение циклов.
		// Эта задача легко решается с помощью поиска в глубину, поскольку любое обратное ребро дерева DFS принадлежит циклу, состоящему из этого ребра плюс путь в дереве, соединяющий два узла.
		// Таким образом, можно немедленно воспользоваться поиском в глубину с целью выявления циклов:
		// граф является ациклическим тогда и только тогда, когда во время выполнения поиска в глубину не встречаются обратные(или прямые!) ребра.
		// Более того, нет необходимости проверять все ребра:
		// мы знаем, что должны найти цикл или завершить поиск, не обнаружив его, прежде чем проверим V ребер, поскольку любой граф с Кили большим числом ребер должен содержать в себе цикл.
		// - Простой путь.
		// Существует ли путь в графе, который связывает две заданных вершины?
		// - Простая связность.
		// мы за линейное время определяем, является ли граф связным, всякий раз, когда пользуемся поиском в глубину.
		// При проведении поиска в глубину граф относится к категории связных тогда и только тогда, когда функция поиска на графе вызывает рекурсивную функцию DFS всего лишь один раз.
		// Число связных компонент в графе в точности равно числу вызовов рекурсивной функции из функции GRAPHsearch, следовательно, число связных компонент графа можно определить путем простого подсчета числа таких вызовов.
		// Конструктор СС вычисляет за линейное время количество связных компонент заданного графа и сохраняет индекс компоненты, ассоциированной с каждой вершиной, в приватном векторе id, проиндексированном именами вершин.
		// Клиентские программы могут использовать объект СС для определения за постоянное время числа связных компонентов(count) или для проверки(connect), является ли связанной конкретная пара вершин.
		// Какими преимуществами решение задачи определения связности графа, использующее поиск в глубину обладает перед подходом, использующим алгоритм объединения - поиска, который рассматривался в главе 1 применительно к решению задачи определения связности графа, в случае, когда граф задан списком ребер?
		// Теоретически поиск в глубину обладает большим быстродействием, чем алгоритм объединения - поиска, поскольку он обеспечивает постоянное время выполнения, в то время как алгоритм объединения - поиска не способен на это;
		// на практике, однако, эта разница незначительна.
		// В конечном итоге, алгоритм объединения-поиска выполняется быстрее, поскольку для него не надо строить полное представление графа.
		// Что еще важнее, алгоритм объединения - поиска работает в оперативном режиме(мы можем проверить, имеется ли связь между двумя какими - либо вершины за время, близкое к постоянному), в то время как решение, использующее поиск в глубину, должно выполнить предварительную обработку, чтобы ответить на запрос о связности за постоянное время.
		// - Двухпроходный эйлеров цикл.
		// - Остовный лес.
		// - Поиск вершин.
		// - Раскраска в два цвета, двухдольные графы, нечетные циклы.
		// Существует ли способ покрасить каждую вершину в два цвета таким образом, что ни одно из ребер не соединяет вершины одного и того же цвета?
		// Принадлежит ли заданный граф к категории двудольных?
		// Содержит ли заданный граф цикл нечетной длины?
		// Все эти три задачи эквивалентны.

		// 18.6.Отделимость и бисвязность
		// Мы займемся изучением проблем такого рода:
		// пусть заданы две вершины, существуют ли два различных пути, связывающих эти вершины?
		// В некоторых ситуациях, когда важно, чтобы граф был связным, может оказаться существенным тот факт, что он остается связным, если убрать из него какую - либо вершину или ребро.
		// Упомянутые примеры принципиально отличаются друг от друга:
		// в случае интегральной схемы и сети связи мы заинтересованы в сохранении соединения, когда удаляется ребро;
		// в случае авиа - и железнодорожных сообщений мы хотим сохранить соединение, когда удаляется вершина.Мы начнем с того, что подробно рассмотрим второй случай.
		// Определение 18.1. Мостом (bridge) в графе называется ребро, после удаления которого связный граф распадается на два не связанных между собой подграфа.
		// Граф, у которого нет мостов, называется реберно - связным(edge - connected).
		// мы называет граф, который относится к категории реберно - связных, реберно - отделимым(edge - separable) и назовем мосты ребрами отделимости(separation edges).
		// Если мы удалим все мосты в реберно - отделимом графе, мы разделим его на реберно - связные компоненты(edge - connected components) или компоненты, связанные мостами(bridge -connected components) — максимальные подграфы, не имеющие мостов.
		// Свойство 18.5. В любом дереве DFS ребро v-w есть мост тогда и только тогда, когда не существует обратное ребро, которое соединяет один из потомков w с каким - либо предком w.
		// Свойство 18.6. Мосты графа обнаруживаются за линейное время 
		// Определение 18.2. Точка сочленения (articulation point) графа есть вершина, в случае удаления которой связный граф распадается, по меньшей мере, на два непересекающихся подграфа.
		// Мы будем также называть точки сочленения графа вершинами отделимости (separation vertices) или разрезающими вершинами (cut vertex).
		// Определение 18.3. Граф называется двусвязным (biconnected), если каждая пара вершин соединена двумя непересекающимися путями.
		// Требование непересекающихся (disjoint) путей отличает двухвязность от реберной связности.
		// Двусвязность представляет собой более сильное условие: реберно - связный граф остается связным, если мы удалим из него какую - нибудь вершину(и все ребра, инцидентные этой вершине).
		// Каждый двусвязный граф есть реберно - связный граф, однако реберно - связный граф не обязательно должен быть двусвязным.
		// Мы также пользуемся термином сепарабелъный (separable) в отношении к графу, который не является двусвязным, поскольку за счет удаления всего лишь одной вершины он может быть разделен на две части.
		// Наличие вершин отделимости являются ключевым свойством двусвязности.
		// Свойство 18.7. Граф двусвязен тогда и только тогда, когда он не содержит вершин отделимости(точек сочленения).
		// Свойство 18.8. Точки сочленения и двусвязные компоненты графа можно обнаружить за линейное время.
		// Определение 18.4. Граф называется k-связным (k-connected), если существуют, по меньшей мере, k непересекающихся по вершинам путей, соединяющих каждую пару вершин графа.
		// Вершинная связность(vertex connectivity) графа есть минимальное число вершин, которые нужно удалить, чтобы разделить этот граф на две части.
		// Определение 18.5. Граф называется k—реберно-связным (k—edge-connected), если существуют, по меньшей мере, k путей, которые не имеют общих ребер, соединяющих каждую пару вершин графа.
		// Реберная связность(edge connectivity) графа есть минимальное число ребер у которые нужно удалить, чтобы разделить этот граф на две части.
		// - st-связностъ.
		// Каким является минимальное число ребер, удаление которых приведет к разделению двух конкретных вершин s и t заданного графа?
		// Чему равно минимальное число вершин, удаление которых приведет к разделению двух заданных вершин s и t заданного графа?
		// - Общая связность.
		// Является ли заданный граф k-связным?
		// Является ли заданный граф k-реберно-связным?
		// Какой является реберная связность и вершинная связность заданного графа?

		// 18.7. Поиск в ширину 
		// Предположим, что мы хотим найти кратчайший путь (shortest path) между двумя конкретными вершинами некоторого графа - путь, соединяющий вершины, обладающие тем свойством, что никакой другой путь, соединяющий эти вершины, не содержит меньшее число ребер.
		// Классический метод решения этой задачи, получивший название поиска в ширину(BFS — breath-first search), служит основой многочисленных алгоритмов обработки графов.
		// Поиск кратчайшего пути от вершины v к вершине w мы начнем с того, что среди всех вершин, в которые можно перейти по одному ребру из вершины v, мы попытаемся обнаружить вершину w, затем мы проверяем все вершины, в которые мы можем перейти по двум ребрам, и т.д.
		// в компьютерной программе эта цель достигается намного проще : мы просто вместо стека используем очередь FIFO(FIFO queue - первым пришел, первым обслужен).
		// Для исходной вершины мы помещаем в очередь фиктивную петлю, после чего выполняем следующие действия до тех пор, пока очередь не опустеет:
		// - Выбираем ребра из очереди до тех пор, пока не найдем такое ребро, которое ведет на непосещенную вершину.
		// - Просматриваем эту вершину; ставим в очередь все ребра, исходящие из этой вершины в вершины, которые мы еще не посещали.
		// Что касается поиска в ширину, то наибольший интерес для нас представляет расстояние каждой вершины от исходной вершины(длина кратчайшего пути, соединяющего две эти вершины).
		// Свойство 18.9. В процессе поиска в ширину вершины поступают в очередь FIFO и покидают ее в порядке, определяемом их расстоянием от исходной вершины.
		// Вектор st есть представление дерева в виде родительских связей, которое мы можем использовать при поиске кратчайшего пути из любого узла в корень.
		//...134


	}
}

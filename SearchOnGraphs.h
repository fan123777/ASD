#pragma once

#include <vector>

namespace nsAlgorithmsOnGraphs
{
	// Поиск на графе 
	namespace nsSearchOnGraphs
	{
		void main();

		void test();


		// В данной главе мы рассматриваем фундаментальные алгоритмы поиска на графах(graph search), которые используются для перемещения по графам, с изучением по мере продвижения его структурных свойств.
		// В частности, рекурсивный алгоритм DFS (depth-first search - поиск в глубину) точно соответствует конкретпой стратегии исследования лабиринта.
		// Возможны 2 реализации этого базового алгоритма; одна в виде рекурсивной процедуры и другая - с использованием явно заданного стека.
		// Замена стека очередью FIFO (First in First Out - первым пришел, первым обслужен) приводит к другому классическому алгоритму — к алгоритму BFS(breadth - first search - поиск в ширину), который используется для решения других задач обработки графов, связанных с нахождением кратчайших путей.
		// Основной темой, рассматриваемой в данной главе, являются алгоритмы поиска в глубину, поиска в ширину и другие связанные с ними алгоритмы, а также их применение при обработке графов.

		// 18.1. Исследование лабиринта
		// Использование терминов лабиринт(maze) вместо граф, коридор(passage) вместо ребро и перекресток (intersection) вместо вершина есть ни что иное, как просто семантическое различие, однако на данной стадии переход на другую терминологию поможет глубже прочувствовать задачу.
		// Один из приемов, заключается в том, чтобы разматывать клубок по мере продвижения вглубь лабиринта.
		// Следующая стратегия исследования лабиринта, которую мы будем называть исследованием Тремо(Tremaux exploration), известна, по меньшей мере, с девятнадцатого столетия:
		// 1) Если на текущем перекрестке нет закрытых дверей, переходите к шагу(3).
		// В противном случае откройте любую дверь любого коридора, ведущую из текущего перекрестка(и оставьте ее открытой).
		// 2) Если вы видите, что лампа, установленная на перекрестке на другом конце этого коридора уже включена, попробуйте открыть другую дверь на текущем перекрестке(шаг(1)).
		// Иначе(если вы видите, что перекресток на другом конце соответствующего коридора не освещен), проследуйте по коридору к этому перекрестку, разматывая при этом нить, включите свет и переходите к шагу(1).
		// 3) Если все двери на текущем перекрестке открыты, проверьте, не находитесь ли вы в отправной точке.
		// Если да, то процесс окончен.
		// Если нет, воспользуйтесь нитью, чтобы двигаться назад вдоль коридора, который привел вас в этот перекресток в первый раз, разматывая нить по мере продвижения, и ищите другую замкнутую дверь уже там(т.е.вернитесь к шагу(1).
		// Свойство 18.1.Когда мы проводим исследование Тремо некоторого лабиринта, мы зажигаем все лампы и открываем все двери в лабиринте и завершаем обход там, где его начинали.
		// мы видим, что существуют четыре различных ситуаций, которые возникают при выборе очередного коридора и которые мы должны учитывать, принимая одно из возможных решений:
		// 1) Коридор не освещен, следовательно, мы его выбираем.
		// 2) Коридор уже был использован (в нем мы размотали нить), следовательно, мы выбираем его (и сматываем нить в клубок).
		// 3) Дверь на другом конце коридора закрыта (но сам перекресток освещен), в силу этого обстоятельства мы пропускаем этот коридор.
		// 4) Дверь на другом конце коридора открыта (а перекресток освещен), в силу этого обстоятельства мы пропускаем этот коридор.
		
		// 18.2. Поиск в глубину
		// посетив конкретную вершину, мы помечаем ее специальной меткой, свидетельствующей о том, что она посещена, затем, в режиме рекурсии, мы посещаем все смежные с нею вершины, которые еще не были помечены.
		// метода поиска в глубину (DFS — depth-first search).
		// Это дерево рекурсивных вызовов, известное как дерево DFS, обеспечивает структурное описание процесса поиска.
		// Порядок обхода вершин зависит не только от графа, но и от его представления и реализации АТД.
		// Несмотря на все эти возможности, критичным остается тот факт, что алгоритм поиска в глубину посещает все ребра и все вершины, связанные с исходной вершиной, независимо от того, в какой последовательности он проверяет ребра, инцидентные каждой вершине.
		
		// 18.3. Функции АТД поиска на графе 
		// переход от вершины к вершине вдоль ребер может провести через все вершины только в рамках одной и той же связной компоненты, которой принадлежит исходная вершина.
		// Обычно мы используем функции поиска на графе, которые, пока все вершины графа не будут помечены как посещенные, выполняют следующие действия:
		// - Найти непомеченную вершину (отправная вершина).
		// - Посетить (и пометить как посещенные) все вершины в связной компоненте, которая содержит отправную вершину.
		// ...105
	}
}

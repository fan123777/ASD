#pragma once

namespace nsSearch
{
	// Таблицы символов и деревья бинарного поиска
	namespace nsCharacterTablesAndBinarySearchTrees
	{
		void main();

		// Программа 12.3 Пример клиента для таблицы символов
		void program3();

		// Программа 12.11 Пример индексирования текстовых строк
		void program11();


		// Получение конкретного фрагмента или фрагментов информации из больших томов ранее сохраненных данных - основополагающая операция, называемая поиском, характерная для многих вычислительных задач.
		// мы работаем с данными, разделенными на записи, или элементы, каждый из которых имеет ключ, используемый при поиске.Цель поиска - отыскание элементов с ключами, которые соответствуют заданному ключу поиска.
		// Определение 12.1 Таблица символов - это структура данных элементов с ключами, которая поддерживает две базовых операции : вставку нового элемента и возврат элемента с заданным ключом.
		// Иногда таблицы символов называют также словарями (dictionary).
		
		// 12.1 Абстрактный тип данных таблицы символов
		// Как и при рассмотрении очередей приоритета, алгоритмы поиска можно рассматривать как принадлежащие к интерфейсам, объявляющим множество общих операций, которые могут быть отделены от конкретных реализаций, что позволяет легко и просто заменять одни реализации другими.Интерес представляют следующие операции:
		// - Вставка нового элемента.
		// - Поиск элемента(или элементов) с заданным ключом.
		// - Удаление указанного элемента.
		// - Выбор k-то по величине элемента в таблице символов.
		// - Сортировка таблицы символов (отображение всех элементов в порядке их ключей).
		// - Объединение двух таблиц символов.
		// Подобно множеству других структур данных, к этому набору может потребоваться добавить стандартные операции создания, проверки, не пуст ли элемент и, возможно, уничтожения и копирования.
		// В некоторых алгоритмах не предполагается наличие какого-либо определенного порядка ключей, и поэтому для сравнения ключей в них используется только operator== (a не operator<), однако во многих реализациях таблиц символов используется упорядоченная организация ключей, применяемых в operator< для структурирования данных и управления поиском.
		// Кроме того, абстрактные операции select(выбор) и sort(сортировка) явно ссылаются на порядок ключей.
		// Как обычно, следует иметь в виду, что различные реализации операций на таблицах символов обладают различными характеристиками производительности, которые могут зависеть от конкретного набора операций.В одном приложении операция insert может использоваться сравнительно редко(возможно, для построения таблицы) при огромном количестве выполняемых операций search; в другом, в сравнительно небольших таблицах, может выполняться огромное количество операций insert и remove, перемежаемое операциями search.
		
		// 12.2 Поиск с использованием индексации по ключам 
		// Предположим, что значения ключей - отдельные небольшие числа.
		// В этом случае простейший алгоритм поиска основывается на сохранении элементов в массиве, индексированном по ключам, как сделано в реализации, приведенной в программе 12.4.
		// Реализации операций выбора (select), сортировки (sort) и подсчета (count) в программе 12.4 используют линейный просмотр массива с пропуском нулевых элементов.
		// Если элементы вообще отсутствуют (имеются только ключи), можно использовать таблицу бит.
		// В этом случае таблица символов называется таблицей существования (existence table), поскольку k-ый разряд можно считать признаком существования к в наборе ключей таблицы.
		// Лемма 12.1 Если значения ключей - положительные целые числа меньшие М, и элементы имеют различные ключи, то тип данных таблицы символов может быть реализован посредством индексированных по ключам массивов элементов так, чтобы для выполнения операций insert, search и remove требовалось постоянное время;
		// Время для выполнения операций initialize, select и sort пропорционально М всегда, когда любая из операций выполняется по отношению к таблице, состоящей из N-элементов.
		// Реализация операции count в программе 12.4 - пример "ленивого" подхода, когда действия выполняются только при вызове функции count.
		// Альтернативный("энергичный") подход заключается в поддержке локальной переменной счетчика непустых позиций таблицы с увеличением значения переменной, когда вставка(insert) выполняется в позицию таблицы, содержащую nullltem, и с уменьшением значения счетчика, если удаление(remove) выполняется по отношению к позиции таблицы, не содержащей nullItem.
		// "Ленивый" подход предпочтительнее, если операция count используется редко(или вообще не используется), а количество возможных значений ключей мало;
		// "энергичный" подход предпочтительнее, если операция count используется часто или если количество возможных значений ключей очень велико.
		// Для подпрограммы библиотеки общего назначения "энергичный" подход предпочтительней, поскольку он обеспечивает оптимальную производительность для наихудшего случая при небольшом постоянном коэффициенте увеличения затрат на выполнение операций insert и remove.
		
		// 12.3 Последовательный поиск 
		// В общем случае, когда значения ключей относятся к слишком большому диапазону, чтобы их можно было использовать в качестве индексов, один из простых подходов к реализации таблиц символов - последовательное сохранение элементов в массиве в упорядоченном виде.
		// Когда требуется вставить новый элемент, мы вставляем его в массив, перемещая большие элементы на одну позицию, как это делалось для сортировки вставками;
		// когда необходимо выполнить поиск, массив просматривается последовательно.
		// Поскольку массив упорядочен, при встрече ключа, значение которого больше искомого, можно сделать вывод о неудаче поиска.
		// Другой подход связан с созданием реализации, в которой размещение элементов в массиве по порядку не является обязательным.При вставке новый элемент помещается в конец массива; во время поиска массив просматривается последовательно.
		// Этот подход характеризуется тем, что операция insert выполняется быстро, а операции select и sort требуют значительно большего объема работы.
		// Удаление(remove) элемента с указанным ключом можно выполнить, отыскав его, а затем переместив последний элемент массива в позицию удаляемого элемента и уменьшив размер массива на 1;
		// удаление всех элементов с заданным ключом реализуется путем повторения этой операции.
		// Если доступен дескриптор, предоставляющий индекс элемента в массиве, поиск не требуется и операция remove выполняется за постоянное время.
		// Еще одна простая реализация таблицы символов - использование связного списка. 
		// В этом случае можно также хранить список в упорядоченном виде с целью урощения поддержки операции sort либо оставить его неупорядоченным для ускорения операции insert.
		// Как обычно, преимущество применения связных списков по сравнению с массивами состоит в том, что вовсе не обязательно заранее точно определять максимальный размер таблицы, а недостаток - в необходимости расхода дополнительного объема памяти(под ссылки) и невозможности эффективной поддержки операции select.
		// Сохранение элементов в упорядоченном виде - иллюстрация идеи, что в о общем случае в реализациях таблиц символов ключи используются для определенной структуризации данных в целях ускорения поиска.
		// Чтобы подробнее проанализировать последовательный поиск произвольных ключей, начнем с рассмотрения затрат на вставку новых ключей и отдельно рассмотрим случаи успешного и неуспешного поиска.
		// Первый часто называют попаданием при поиске, а второй - промахом при поиске.
		// Лемма 12.2 При последовательном поиске в таблице символов с N элементами для выявления попаданий при поиске требуется выполнение около N/2 сравнений(в среднем).
		// Лемма 12.3 При последовательном поиске в таблице символов, содержащей N неупорядоченных элементов, используется постоянное количество шагов для выполнения вставок и N сравнений для выявления промахов при поиске(всегда).
		// Лемма 12.4 Для вставки, обнаружения попаданий и промахов при последовательном поиске в таблице символов, содержащей N упорядоченных элементов, требуется выполнение приблизительно N / 2 операций сравнения(в среднем).
		// Использование неупорядоченной таблицы предпочтительнее для приложений, в которых выполняется огромное количество операций insert при сравнительно небольшом числе операций search.
		// Помимо учета этих различий, приходится, как обычно, идти на компромисс:
		// - для реализаций с использованием связных списков требуется дополнительный объем памяти для ссылок.
		// - в то время как для реализаций с использованием массивов необходимо заранее знать максимальный размер таблицы или же предусмотреть увеличение таблицы с течением времени.
		// Кроме того, как упоминалось в разделе 12.5, использование связных списков обладает гибкостью, позволяющей эффективно реализовать другие операции типа join и remove.
		
		// 12.4 Бинарный поиск
		// Лемма 12.5 При бинарном поиске никогда не используется более чем |_lgN_| + 1 сравнений(для выявления попадания или промаха).
		// Поддержка таблицы в отсортированном виде, как это делается при сортировке вставками, приводит к тому, что время выполнения становится квадратичной функцией от количества операций insert, но эта стоимость может оказаться приемлемой или ею даже можно пренебречь, если количество операций search очень велико.
		// В типичной ситуации, когда все элементы(или большая их часть) доступны до начала поиска, можно построить(construct) таблицу символов с помощью конструктора, который принимает массив в качестве аргумента и использует один из стандартных методов сортировки, описанных в главе 6 и последующих главах, для сортировки таблицы во время инициализации.
		// Упомянутая вероятность высокой стоимости обновления таблицы - наибольший недостаток использования бинарного поиска.
		// С другой стороны, существует огромное число приложений, в которых статическая таблица может быть заранее отсортированой и в этом случае, благодаря быстрому доступу, обеспечиваемому такими реализациями, как программа 12.7, бинарный поиск является наиболее предпочтительным методом.
		// Для реализации данного метода, называемого интерполяционным поиском(interpolation search), программу 12.7 потребуется изменить следующим образом : оператор
		// m = (l + r) / 2
		// заменяется на оператор
		// m = l + (v - a[l].key())*(r - l) / (a[r].key() - a[l].key());
		// lg(lg(N))
		// Однако интерполяционный поиск в значительной степени основывается на предположении, что ключи распределены во всем интервале более-менее равномерно - в противном случае, что обычно и имеет место на практике, метод окажется неэффективным.
		
		// 12.5 Деревья бинарного поиска 
		// Лежащая в основе структура данных позволяет разрабатывать алгоритмы с высокой средней производительностью выполнения операций search, insert, select и sort в таблицах символов.
		// Этот метод используется во множестве приложений и в компьютерных науках считается одним из наиболее фундаментальных.
		// Определяющее свойство дерева (tree) заключается в том, что каждый узел указывается только одним другим узлом, называемым родительским(parent).
		// Определяющее свойство бинарного дерева - наличие у каждого узла левой и правой связей.
		// Связи могут указывать на другие двоичные деревья или на внешние(external) узлы, которые не имеют связей.
		// Узлы с двумя связями называются также внутренними (internal) узлами.
		// Для выполнения поиска каждый внутренний узел имеет также элемент со значением ключа, а связи с внешними узлами называются нулевыми(null) связями.
		// Значения ключей во внутренних узлах сравниваются в ключом поиска и управляют протеканием поиска.
		// Лемма 12.2 Дерево бинарного поиска (BST) - это бинарное дерево, с каждым из внутренних узлов которого связан ключ, причем ключ в любом узле больше(или равен) ключам и во всех узлах левого поддерева этого узла и меньше(или равен) ключам во всех узлах правого поддерева этого узла.
		// При наличии этой структуры рекурсивный алгоритм поиска ключа в BST-дереве становится очевидным:
		// - если дерево пусто, имеет место промах припоиске;
		// - если ключ поиска равен ключу в корне, имеет место попадание при поиске.
		// Деревья бинарного поиска - аналог быстрой сортировки.
		// Узел в корне дерева соответствует разделяющему элементу при быстрой сортировке(никакие ключи слева от него не могут быть больше, и никакие ключи справа не могут быть меньше него).
		
		// 12.6 Характеристики производительности деревьев бинарного поиска
		// Время выполнения алгоритмов обработки BST-деревьев зависит от форм деревьев.
		// В лучшем случае дерево может быть полностью сбалансированным и содержать приблизительно lgN узлов между корнем и каждым из внешних узлов, но в худшем случае в каждый из путей поиска может содержать N узлов.
		// В частности, длина пути и высота бинарных деревьев, рассмотренные в разделе 5.5, непосредственно связаны с затратами на поиск в BST-деревьях.
		// Высота определяет стоимость поиска в худшем случае, длина внутреннего пути непосредственно связана со стоимостью попаданий при поиске, а длина внешнего пути непосредственно связана со стоимостью промахов при поиске.
		// Лемма 12.6 Для обнаружения попадания при поиске в дереве бинарного поиска, образованном N произвольными ключами, в среднем требуется около 2*lg(N) = 1.39*lg(N) сравнений.
		// Лемма 12.7 Для выполнения вставок и обнаружения промахов при поиске в дереве бинарного поиска, образованном N произвольными ключами, в среднем требуется около 2*lg(N) = 1.39*lg(N) сравнений.
		// Лемма 12.8 В худшем случае для поиска в дереве бинарного поиска с N ключами может требоваться N сравнений.
		
		// 12.7 Реализация индексов при использовании таблиц символов
		// необходимо использовать контейнер Index для определения элементов BST-дерева и обеспечить, чтобы ключи извлекались из элементов, как обычно, через функцию-члена key.
		// Более того, для связей можно использовать параллельные массивы, как это было сделано для связных списков в главе 3.
		// Используются три массива : для элементов, левых связей и правых связей.
		// Связи являются индексами массивов(целыми значениями) и ссылки на связи, подобные
		// x = x->1
		// во всем коде заменяются на ссылки типа
		// х = l[х]
		// Другая важная особенность этого подхода заключается в том, что он допускает добавление дополнительных массивов(содержащих дополнительную связанную с каждым узлом информацию) без какого-либо изменения кода манипулирования деревом.
		
		// 12.8 Вставка в корень в деревьях бинарного поиска 
		// В этом разделе рассматривается другой метод вставки, при котором каждый новый элемент вставляется в корень, и поэтому недавно вставленные узлы находятся вблизи вершины дерева.
		// существует простое рекурсивное решение этой проблемы, которое основывается на ротации(rotation) - фундаментальном преобразовании деревьев.
		// Ротация вправо затрагивает корень и левый дочерний узел.
		// Ротация помещает корень справа, изменяя на обратное направление левой связи корня:
		// перед ротацией она указывает от корня к левому дочернему узлу, а после ротации — от левого дочернего узла(нового корня) к старому корню(правый дочерний узел нового корня).
		// Основная часть, которая обеспечивает работу ротации, — копирование правой связи левого дочернего узла, чтобы она стала левой связью старого корня.
		// Эта связь указывает на все узлы с ключами между двумя узлами, участвующими в ротации.
		// И наконец, связь со старым корнем должна быть изменена так, чтобы указывать на новый корень.
		// Ротации используются для перемещения конкретных узлов по дереву и для предотвращения разбалансировки деревьев.
		// Это важно, поскольку во многих приложениях выполняется именно такой динамический набор операций search и insert.
		// Таблица символов может содержать изрядное количество элементов, но значительная часть поисков может относится к наиболее недавно вставленным элементам.

		// 12.9 Реализации других функций АТД с помощью BST - дерева
		// В общем случае операции связаны с перемещением вниз по дереву; поэтому для случая произвольного BST-дерева можно ожидать, что затраты будут определяться логарифмической зависимостью.
		// С точки зрения алгоритма основная причина включения полей счетчика в узлы BST-дерева — необходимость поддержки реализации операции select.
		// Это позволяет также обеспечивать тривиальную реализацию операции count(возвращение поля счетчика в коневом узле);
		// Эту реализацию операции select можно преобразовать в операцию partition(разбиение на части), которая реорганизует дерево для помещения k-го наименьшего элемента в корень,
		// Для удаления узла с данным ключом из BST-дерева вначале необходимо проверить, находится ли он в одном из поддеревьев.
		// Если да, мы заменяем это поддерево результатом удаления(рекурсивного) из него узла.
		// Если удаляемый узел находится в корне, дерево заменяется результатом объединения двух поддеревьев в одно.
		// Для объединения двух BST-деревьев, все ключи второго из которых заведомо больше ключей первого, ко второму дереву применяется операция partition с целью перемещения в корень наименьшего элемента в этом дереве.
		// Основная сложность в реализации функции для удаления узла с данным дескриптором(связью) та же, что имела место в случае связных списков : необходимо изменить указатель в структуре, который указывает на удаляемый узел.
		// Программа 12.17 - компактная, линейная по затратам времени рекурсивная реализация операции join.
		// Несмотря на всю полезность, существует два основных недостатка использования BST-деревьев в приложениях.
		// Во-первых, они требуют существенного дополнительного объема памяти для связей.
		// Второй недостаток использования BST-деревьев - возможность того, что деревья могут стать плохо сбалансированными и в результате снижать производительность.
	}
}

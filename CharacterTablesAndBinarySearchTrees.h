#pragma once

namespace nsSearch
{
	// Таблицы символов и деревья бинарного поиска
	namespace nsCharacterTablesAndBinarySearchTrees
	{
		void main();

		// Программа 12.3 Пример клиента для таблицы символов
		void program3();


		// Получение конкретного фрагмента или фрагментов информации из больших томов ранее сохраненных данных - основополагающая операция, называемая поиском, характерная для многих вычислительных задач.
		// мы работаем с данными, разделенными на записи, или элементы, каждый из которых имеет ключ, используемый при поиске.Цель поиска - отыскание элементов с ключами, которые соответствуют заданному ключу поиска.
		// Определение 12.1 Таблица символов - это структура данных элементов с ключами, которая поддерживает две базовых операции : вставку нового элемента и возврат элемента с заданным ключом.
		// Иногда таблицы символов называют также словарями (dictionary).
		
		// 12.1 Абстрактный тип данных таблицы символов
		// Как и при рассмотрении очередей приоритета, алгоритмы поиска можно рассматривать как принадлежащие к интерфейсам, объявляющим множество общих операций, которые могут быть отделены от конкретных реализаций, что позволяет легко и просто заменять одни реализации другими.Интерес представляют следующие операции:
		// - Вставка нового элемента.
		// - Поиск элемента(или элементов) с заданным ключом.
		// - Удаление указанного элемента.
		// - Выбор k-то по величине элемента в таблице символов.
		// - Сортировка таблицы символов (отображение всех элементов в порядке их ключей).
		// - Объединение двух таблиц символов.
		// Подобно множеству других структур данных, к этому набору может потребоваться добавить стандартные операции создания, проверки, не пуст ли элемент и, возможно, уничтожения и копирования.
		// В некоторых алгоритмах не предполагается наличие какого-либо определенного порядка ключей, и поэтому для сравнения ключей в них используется только operator== (a не operator<), однако во многих реализациях таблиц символов используется упорядоченная организация ключей, применяемых в operator< для структурирования данных и управления поиском.
		// Кроме того, абстрактные операции select(выбор) и sort(сортировка) явно ссылаются на порядок ключей.
		// Как обычно, следует иметь в виду, что различные реализации операций на таблицах символов обладают различными характеристиками производительности, которые могут зависеть от конкретного набора операций.В одном приложении операция insert может использоваться сравнительно редко(возможно, для построения таблицы) при огромном количестве выполняемых операций search; в другом, в сравнительно небольших таблицах, может выполняться огромное количество операций insert и remove, перемежаемое операциями search.
		
		// 12.2 Поиск с использованием индексации по ключам 
		// Предположим, что значения ключей - отдельные небольшие числа.
		// В этом случае простейший алгоритм поиска основывается на сохранении элементов в массиве, индексированном по ключам, как сделано в реализации, приведенной в программе 12.4.
		// Реализации операций выбора (select), сортировки (sort) и подсчета (count) в программе 12.4 используют линейный просмотр массива с пропуском нулевых элементов.
		// Если элементы вообще отсутствуют (имеются только ключи), можно использовать таблицу бит.
		// В этом случае таблица символов называется таблицей существования (existence table), поскольку k-ый разряд можно считать признаком существования к в наборе ключей таблицы.
		// Лемма 12.1 Если значения ключей - положительные целые числа меньшие М, и элементы имеют различные ключи, то тип данных таблицы символов может быть реализован посредством индексированных по ключам массивов элементов так, чтобы для выполнения операций insert, search и remove требовалось постоянное время;
		// Время для выполнения операций initialize, select и sort пропорционально М всегда, когда любая из операций выполняется по отношению к таблице, состоящей из N-элементов.
		// Реализация операции count в программе 12.4 - пример "ленивого" подхода, когда действия выполняются только при вызове функции count.
		// Альтернативный("энергичный") подход заключается в поддержке локальной переменной счетчика непустых позиций таблицы с увеличением значения переменной, когда вставка(insert) выполняется в позицию таблицы, содержащую nullltem, и с уменьшением значения счетчика, если удаление(remove) выполняется по отношению к позиции таблицы, не содержащей nullItem.
		// "Ленивый" подход предпочтительнее, если операция count используется редко(или вообще не используется), а количество возможных значений ключей мало;
		// "энергичный" подход предпочтительнее, если операция count используется часто или если количество возможных значений ключей очень велико.
		// Для подпрограммы библиотеки общего назначения "энергичный" подход предпочтительней, поскольку он обеспечивает оптимальную производительность для наихудшего случая при небольшом постоянном коэффициенте увеличения затрат на выполнение операций insert и remove.
		
		// 12.3 Последовательный поиск 
		// В общем случае, когда значения ключей относятся к слишком большому диапазону, чтобы их можно было использовать в качестве индексов, один из простых подходов к реализации таблиц символов - последовательное сохранение элементов в массиве в упорядоченном виде.
		// Когда требуется вставить новый элемент, мы вставляем его в массив, перемещая большие элементы на одну позицию, как это делалось для сортировки вставками;
		// когда необходимо выполнить поиск, массив просматривается последовательно.
		// Поскольку массив упорядочен, при встрече ключа, значение которого больше искомого, можно сделать вывод о неудаче поиска.
		// Другой подход связан с созданием реализации, в которой размещение элементов в массиве по порядку не является обязательным.При вставке новый элемент помещается в конец массива; во время поиска массив просматривается последовательно.
		// Этот подход характеризуется тем, что операция insert выполняется быстро, а операции select и sort требуют значительно большего объема работы.
		// Удаление(remove) элемента с указанным ключом можно выполнить, отыскав его, а затем переместив последний элемент массива в позицию удаляемого элемента и уменьшив размер массива на 1;
		// удаление всех элементов с заданным ключом реализуется путем повторения этой операции.
		// Если доступен дескриптор, предоставляющий индекс элемента в массиве, поиск не требуется и операция remove выполняется за постоянное время.
		// Еще одна простая реализация таблицы символов - использование связного списка. 
		// В этом случае можно также хранить список в упорядоченном виде с целью урощения поддержки операции sort либо оставить его неупорядоченным для ускорения операции insert.
		// Как обычно, преимущество применения связных списков по сравнению с массивами состоит в том, что вовсе не обязательно заранее точно определять максимальный размер таблицы, а недостаток - в необходимости расхода дополнительного объема памяти(под ссылки) и невозможности эффективной поддержки операции select.
		// Сохранение элементов в упорядоченном виде - иллюстрация идеи, что в о общем случае в реализациях таблиц символов ключи используются для определенной структуризации данных в целях ускорения поиска.
		// Чтобы подробнее проанализировать последовательный поиск произвольных ключей, начнем с рассмотрения затрат на вставку новых ключей и отдельно рассмотрим случаи успешного и неуспешного поиска.
		// Первый часто называют попаданием при поиске, а второй - промахом при поиске.
		// Лемма 12.2 При последовательном поиске в таблице символов с N элементами для выявления попаданий при поиске требуется выполнение около N/2 сравнений(в среднем).
		// Лемма 12.3 При последовательном поиске в таблице символов, содержащей N неупорядоченных элементов, используется постоянное количество шагов для выполнения вставок и N сравнений для выявления промахов при поиске(всегда).
		// Лемма 12.4 Для вставки, обнаружения попаданий и промахов при последовательном поиске в таблице символов, содержащей N упорядоченных элементов, требуется выполнение приблизительно N / 2 операций сравнения(в среднем).
		// Использование неупорядоченной таблицы предпочтительнее для приложений, в которых выполняется огромное количество операций insert при сравнительно небольшом числе операций search.
		// Помимо учета этих различий, приходится, как обычно, идти на компромисс:
		// - для реализаций с использованием связных списков требуется дополнительный объем памяти для ссылок.
		// - в то время как для реализаций с использованием массивов необходимо заранее знать максимальный размер таблицы или же предусмотреть увеличение таблицы с течением времени.
		// Кроме того, как упоминалось в разделе 12.5, использование связных списков обладает гибкостью, позволяющей эффективно реализовать другие операции типа join и remove.
		
		// 12.4 Бинарный поиск
		// Лемма 12.5 При бинарном поиске никогда не используется более чем |_lgN_| + 1 сравнений(для выявления попадания или промаха).
		// Поддержка таблицы в отсортированном виде, как это делается при сортировке вставками, приводит к тому, что время выполнения становится квадратичной функцией от количества операций insert, но эта стоимость может оказаться приемлемой или ею даже можно пренебречь, если количество операций search очень велико.
		// В типичной ситуации, когда все элементы(или большая их часть) доступны до начала поиска, можно построить(construct) таблицу символов с помощью конструктора, который принимает массив в качестве аргумента и использует один из стандартных методов сортировки, описанных в главе 6 и последующих главах, для сортировки таблицы во время инициализации.
		// Упомянутая вероятность высокой стоимости обновления таблицы - наибольший недостаток использования бинарного поиска.
		// С другой стороны, существует огромное число приложений, в которых статическая таблица может быть заранее отсортированой и в этом случае, благодаря быстрому доступу, обеспечиваемому такими реализациями, как программа 12.7, бинарный поиск является наиболее предпочтительным методом.
		// Для реализации данного метода, называемого интерполяционным поиском(interpolation search), программу 12.7 потребуется изменить следующим образом : оператор
		// m = (l + r) / 2
		// заменяется на оператор
		// m = l + (v - a[l].key())*(r - l) / (a[r].key() - a[l].key());
		// lg(lg(N))
		// Однако интерполяционный поиск в значительной степени основывается на предположении, что ключи распределены во всем интервале более-менее равномерно - в противном случае, что обычно и имеет место на практике, метод окажется неэффективным.
		
		// 12.5 Деревья бинарного поиска 
		// Лежащая в основе структура данных позволяет разрабатывать алгоритмы с высокой средней производительностью выполнения операций search, insert, select и sort в таблицах символов.
		// Этот метод используется во множестве приложений и в компьютерных науках считается одним из наиболее фундаментальных.
		// Определяющее свойство дерева (tree) заключается в том, что каждый узел указывается только одним другим узлом, называемым родительским(parent).
		// Определяющее свойство бинарного дерева - наличие у каждого узла левой и правой связей.
		// Связи могут указывать на другие двоичные деревья или на внешние(external) узлы, которые не имеют связей.
		// Узлы с двумя связями называются также внутренними (internal) узлами.
		// Для выполнения поиска каждый внутренний узел имеет также элемент со значением ключа, а связи с внешними узлами называются нулевыми(null) связями.
		// Значения ключей во внутренних узлах сравниваются в ключом поиска и управляют протеканием поиска.
		// Лемма 12.2 Дерево бинарного поиска (BST) - это бинарное дерево, с каждым из внутренних узлов которого связан ключ, причем ключ в любом узле больше(или равен) ключам и во всех узлах левого поддерева этого узла и меньше(или равен) ключам во всех узлах правого поддерева этого узла.
		// При наличии этой структуры рекурсивный алгоритм поиска ключа в BST-дереве становится очевидным:
		// - если дерево пусто, имеет место промах припоиске;
		// - если ключ поиска равен ключу в корне, имеет место попадание при поиске.
		// ...501
	}
}
